<!DOCTYPE html>
<html>
<head>
<title>Vizit: Rapid data visualization</title>
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<style>
body {
  font-family: "Open Sans", sans-serif;
  font-size: 0.9em;
}
label {
  font-weight: bold;
}
.trace-control,
select{
  display:block;
  margin-bottom:5px;
}
.chart-title,
.trace-title{
  font-weight: bold;
  text-decoration: underline;
}
.dashboard-outer,
.chart-outer,
.trace-controls{
  margin-bottom:5px;
}
.dashboard-title-descr-outer{
  margin-top: 20px;
  text-align: center;
}
.dashboard-title,
.dashboard-descr{
  margin: auto;
  padding-bottom: 10px;
  max-width: 800px;
}
.dashboard-title-descr-edit{
  display: none;
  max-width: 800px;
  margin: auto;
}
.dashboard-title-descr-outer:hover .dashboard-title-descr-edit{
  display:block;
  position:absolute;
  background-color: white;
  left: 0;
  right: 0;
  z-index: 10;
}
.add-dashboard,
.add-chart,
.add-trace{
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
.remove-dashboard,
.remove-chart{
  color: red;
  display: block;
  margin-bottom: 20px;
}
.remove-filter,
.remove-style{
  color: red;
  margin-left: 10px;
  cursor: pointer;
}
.chart-outer{
  display: inline-block;
  position: relative;
}
.chart{
  width: 400px;
  height: 400px;
  display: inline-block;
  margin: 5px;
}
.chart-caption{
  width: 400px;
  margin: 5px;
  padding: 5px;
  font-size: 0.9em;
}
.chart-controls{
  min-width: 100%;
}
.chart-container + .chart-controls {
  display: none;
}
.chart-outer:hover .chart-container + .chart-controls{
  display:block;
  position: absolute;
  background-color: white;
  z-index: 10;
}
.chart-controls,
.filter-div,
#global-config{
  border: 1px solid lightgray;
}
#global-config-header,
.filters-label,
.styles-label,
.filter-name,
.trace-title,
#download-html,
#download-html-global-filters,
#download-html-no-controls,
#download-json,
#download-raw-data,
#config-url{
  color: #0088cc;
  cursor: pointer;
}
#data-sources-label,
#bottom-controls-label{
  color: #0088cc;
  cursor: pointer;
  display: block;
  font-weight: bold;
}
#bottom-controls{
  display: none;
}
.add-style,
.update-style,
.add-filter,
.update-filter,
#global-config{
  display: none;
}
.add-filter,
#add-global-filter{
  margin-top: 15px;
}

#global-style-file, #add-global-filter{
  display: inline-block;
}
#update-global-filter{
  display: block;
}
.filter-val-slider{
  width: 400px;
  max-width: 100%;
}
text.js-plot-link-container{
  display:none;
}
.chart:hover text.js-plot-link-container{
  display:block;
}
.tooltip-parent{
  position: relative;
  color: coral;
}
.tooltip{
  display: none;
  width: 400px;
  background-color: black;
  color: lightgray;
  border-radius: 5px;
  padding: 10px;
  position: absolute;
  z-index: 1;
  top: 7px;
  left: 7px;
  font-weight: normal;
}
.tooltip-parent:hover .tooltip {
  display: block;
}
/*no-controls-placeholder*/
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.8.0/plotly.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>
<a style="position: absolute; top: 10px; right: 20px; z-index:100;" href="https://github.com/mmowers/vizit" target="_blank">Vizit GitHub</a>
<div id="top-controls">
  <span id="data-sources-label">Data sources / config:
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Only csv and json files are currently allowed, including an optional vizit
        configuration json file (with filename that must start with "vizit-config" and end with ".json").
        when loading a json configuration file, all required data files must also be loaded before
        charts are rendered.
      </span>
    </span>
  </span>
  <div id="data-sources">
    <input type="file" id="file-input" name="file-input" multiple="multiple">
    <ul id="file-list">(no files selected)</ul>
    <input id="url-input" type="text" placeholder="URL to csv">
    <button id="add-url-input">Load</button>
  </div>
  <div id="global-config-header">Global Styles and Filters
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Add a global styling file and set global filters that will apply
        to all charts, unless overridden in specific chart configuration.
      </span>
    </span>
  </div>
  <div id="global-config">
    <div id="global-style-config">
      Styling file:
      <select id="global-style-file" class="standard-file-select">
        <option value="none">none</option>
      </select>
      <span class="tooltip-parent">
        (?)
        <span class="tooltip">
          This file must have three columns with headers of 'column_name', 'column_value', and 'color'. The
          'column_name' and 'column_value' columns must correspond to the column headers and values of the data
          sources, respectively. For 'color' you can use any css color property value, e.g. 'red', '#FF0000', 'rgb(255, 0, 0)' etc.
          For more examples, see <a target="_blank" href="http://web.simmons.edu/~grovesd/comm244/notes/week3/css-colors">this tutorial</a>.
          <br><br>The order of the rows in this file will eventually determine the order of display, but this hasn't yet been added.
        </span>
      </span>
    </div>
    <div id="global-filter-config" class="filter-div">
      <label class="filters-label">Filters</label>
      <select id="add-global-filter"><option value="none">Add Filter</option></select>
      <button id="update-global-filter" class="update-fil-common">Update Filters</button>
    </div>
  </div>
</div>
<div id="report">
  <button class="add-dashboard">Add Dashboard</button>
</div>
<div id="bottom-controls-label">Save / Download</div>
<div id="bottom-controls">
  <span id="download-html">
    Download vizit.html
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Download html file with current chart configuration, all raw data, and full vizit functionality embedded.
      </span>
    </span>
  </span>
  <br>
  <span id="download-html-global-filters">
    Download vizit.html with only global filters
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Download html file with current chart configuration, but hide everything except global filters.
      </span>
    </span>
  </span>
  <br>
  <span id="download-html-no-controls">
    Download vizit.html without controls
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Download html file with current chart configuration, but hide controls.
      </span>
    </span>
  </span>
  <br>
  <span id="download-json">
    Download vizit-config.json
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Download json configuration file with current chart configuration.
        When imported along with the other data files, the current charts will be rendered.
      </span>
    </span>
  </span>
  <br>
  <span id="download-raw-data">
    Download all raw data
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        Download raw data in separate csv files.
      </span>
    </span>
  </span>
  <br>
  <span id="config-url">
    Open config URL
    <span class="tooltip-parent">
      (?)
      <span class="tooltip">
        This will produce and open a URL with configuration embedded in the URL itself.
        This is only useful if all data sources are URLs themselves, but in that case the
        produced URL will be all that is required to load this vizit report.
      </span>
    </span>
  </span>
</div>

<script>
'use strict';
const files = {}; //list of html File objects
let config_load = null; //this gets replaced if we have saved config
const config = {fileNames:[], dashboards:[]}; //fileNames are sorted alphabetically
let rawData = {}; //mapping of filenames to full raw data (or could this keep too much data in memory?)
const traceData = []; //traceData[dash_idx][chart_idx][trace_idx] = {filteredData: {col1:[], col2:[],...}, aggData: {col1:[], col2:[],...}, traces: [{x:[], y:[], sepDims:[],...},...]}.
const globalCache = {}; //key-value lookup, used to store resources requeested via http.
let globalStyles = {}; //e.g. {col_name_1: {col_val_1: {color: '', order:''}}}
let globalColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
          '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5'];
for(let i = 0; i < 10; i++){
  globalColors = globalColors.concat(globalColors); //This doubles globalColors each time.
}
//Maybe instead keep track of if we've already aggregated data a certain way, defined by filename, an index (sorted array of columns), and value column?
let plotlySchema = Plotly.PlotSchema.get(); //I found this on a forum: https://community.plotly.com/t/plotly-json-schema-reference/21261
// Plotly reference links:
// Single page figure reference: https://plotly.com/javascript/reference/ (this has the schema info as well)
// Function reference: https://plotly.com/javascript/plotlyjs-function-reference (including image download, another resource is: https://plotly.com/javascript/static-image-export/)
// Configuration options: https://plotly.com/javascript/configuration-options/

// This was the old way to get the schema (I found it at https://plotly.com/javascript/reference/index/): Uncomment the following section to grab plotly schema (synchronously). First set the global configs to synchronous, then json request, then flip back to async.
// let plotlySchema = {};
// $.ajaxSetup({async: false});
// $.getJSON('https://raw.githubusercontent.com/plotly/plotly.js/master/dist/plot-schema.json', function(data) {
//   plotlySchema = data;
// });
// $.ajaxSetup({async: true});

const chartTypes = {
  'none':{},
  'dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'markers',
    },
    wdgTypes: ['x','y','name','row','col'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines',
    },
    wdgTypes: ['x','y','name','row','col'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines+markers',
    },
    wdgTypes: ['x','y','name','row','col'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'bar':{
    engine: 'plotly',
    attr: {
      type: 'bar',
    },
    wdgTypes: ['x','y','name','row','col'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
    layout:{
      barmode: 'relative',
      legend:{
        traceorder: 'reversed',
      }
    },
  },
  '3D dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter3d',
      mode: 'markers',
    },
    wdgTypes: ['x','y','z','name'],
    required: ['x','y','z'],
    defaultAgg: 'sum',
    aggCol: 'z',
  },
  'histogram':{
    engine: 'plotly',
    attr: {
      type: 'histogram',
      histfunc: 'count',
    },
    wdgTypes: ['x','name','row','col'],
    customWdgLabels: {
      x: 'Values',
    },
    required: ['x'],
    defaultAgg: 'none',
    aggCol: 'none',
  },
  'weighted histogram':{
    engine: 'plotly',
    attr: {
      type: 'histogram',
      histfunc: 'sum',
    },
    wdgTypes: ['x','y','name','row','col'],
    customWdgLabels: {
      x: 'Values',
      y: 'Weights',
    },
    required: ['x','y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'boxplot':{
    engine: 'plotly',
    attr: {
      type: 'box',
      boxmean: true,
      pointpos: 0,
      boxpoints: false,
    },
    wdgTypes: ['y','x','name','row','col'],
    customWdgLabels: {
      y: 'Values',
    },
    required: ['y'],
    defaultAgg: 'none',
    aggCol: 'none',
  },
  'violin':{
    engine: 'plotly',
    attr: {
      type: 'violin',
      box: {
        visible: true,
      },
      meanline: {
        visible: true,
      },
      points: false,
    },
    wdgTypes: ['y','x','name','row','col'],
    customWdgLabels: {
      y: 'Values',
    },
    required: ['y'],
    defaultAgg: 'none',
    aggCol: 'none',
  },
  'US state map (continuous color)':{
    engine:'plotly',
    attr: {
      type: 'choropleth',
      locationmode: 'USA-states',
    },
    wdgTypes: ['locations','z','text'],
    required:['locations','z'],
    defaultAgg: 'sum',
    aggCol: 'z',
    continuousColor: true,
    layout:{
      width: 500,
      height: 500,
      geo: {
        scope:'usa',
        projection:{
          type: 'mercator',
        }
      },
    }
  },
  'custom region map':{
    engine:'plotly',
    attr: {
      type: 'choropleth',
    },
    customIn: {
      geojson: {
        label: 'GeoJSON URL',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining the regions in the data source.'
      },
      featureidkey: {
        label: 'GeoJSON region key',
        type: 'text',
        tooltip: `Enter the key in the geojson file that matches the regions in the data file. Supports nested property, e.g. "properties.name".
                  If empty, the default is "id".`
      },
      geojsonboundaries: {
        label: 'GeoJSON Boundaries URL (optional)',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining region boundaries that are to be drawn (separate from the data).'
      },
    },
    wdgTypes: ['locations','z','text'],
    required:['geojson','locations','z'],
    customWdgLabels: {
      z: 'Color'
    },
    defaultAgg: 'sum',
    aggCol: 'z',
    continuousColor: true,
    layout:{
      width: 500,
      height: 500,
      geo: {
        projection:{
          type: 'mercator',
        }
      },
    }
  },
  'custom region map (mapbox)':{}, //Mostly copied, see below
  'lat/lon/size dot map':{
    engine:'plotly',
    attr: {
      type: 'scattergeo',
      hoverinfo: 'text+name',
    },
    customIn: {
      geojsonboundaries: {
        label: 'GeoJSON Boundaries URL (optional)',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining region boundaries that are to be drawn (separate from the data).'
      },
    },
    wdgTypes: ['lat','lon','name','marker_size','text'],
    required:['lat','lon'],
    defaultAgg: 'none',
    aggCol: 'none',
    layout:{
      width: 500,
      height: 500,
      geo: {
        projection:{
          type: 'mercator',
        }
      },
    }
  },
  'lat/lon/size dot map (mapbox)':{}, //Mostly copied, see below
  'lat/lon/size dot map (continuous color)':{
    engine:'plotly',
    attr: {
      type: 'scattergeo',
      hoverinfo: 'text+name',
    },
    customIn: {
      geojsonboundaries: {
        label: 'GeoJSON Boundaries URL (optional)',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining region boundaries that are to be drawn (separate from the data).'
      },
    },
    wdgTypes: ['lat','lon','marker_color','marker_size','text'],
    required:['lat','lon'],
    defaultAgg: 'none',
    aggCol: 'none',
    layout:{
      width: 500,
      height: 500,
      geo: {
        projection:{
          type: 'mercator',
        }
      },
    }
  },
  'lat/lon/size dot map (continuous color) (mapbox)':{}, //Mostly copied, see below
  'lat/lon/area squares map':{
    engine:'plotly',
    attr: {
      type: 'scattergeo',
      fill: 'toself',
      mode: 'none',
      hoverinfo: 'text+name',
    },
    customIn: {
      geojsonboundaries: {
        label: 'GeoJSON Boundaries URL (optional)',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining region boundaries that are to be drawn (separate from the data).'
      },
    },
    wdgTypes: ['lat','lon','area','name','text'],
    required:['lat','lon','area'],
    defaultAgg: 'none',
    aggCol: 'area',
    layout:{
      width: 500,
      height: 500,
      geo: {
        projection:{
          type: 'mercator',
        }
      },
      showlegend: true,
    }
  },
  'lat/lon/area squares map (mapbox)':{},
  'lat/lon/width line map':{
    engine:'plotly',
    attr: {
      type: 'scattergeo',
      mode: 'lines',
      hoverinfo: 'text+name',
    },
    customIn: {
      geojsonboundaries: {
        label: 'GeoJSON Boundaries URL (optional)',
        type: 'text',
        tooltip: 'Enter a URL to a geoJSON file defining region boundaries that are to be drawn (separate from the data).'
      },
    },
    wdgTypes: ['lat_start','lon_start','lat_end','lon_end','name','line_width','text'],
    required:['lat_start','lon_start','lat_end','lon_end'],
    defaultAgg: 'none',
    aggCol: 'none',
    layout:{
      width: 500,
      height: 500,
      geo:{ //https://plotly.com/javascript/reference/layout/geo/
        projection:{
          type: 'mercator',
        }
      }
    }
  },
  'lat/lon/width line map (mapbox)':{},
};

chartTypes['custom region map (mapbox)'] = JSON.parse(JSON.stringify(chartTypes['custom region map']));
chartTypes['custom region map (mapbox)'].attr.type = 'choroplethmapbox';
chartTypes['custom region map (mapbox)'].layout = {
  width: 800,
  height: 400,
  mapbox: {style: 'carto-positron'},
};

chartTypes['lat/lon/size dot map (mapbox)'] = JSON.parse(JSON.stringify(chartTypes['lat/lon/size dot map']));
chartTypes['lat/lon/size dot map (mapbox)'].attr.type = 'scattermapbox';
chartTypes['lat/lon/size dot map (mapbox)'].layout = {
  width: 800,
  height: 400,
  dragmode: 'zoom',
  mapbox: {style: 'carto-positron', center: { lat: 38, lon: -95 }, zoom: 3 },
};

chartTypes['lat/lon/size dot map (continuous color) (mapbox)'] = JSON.parse(JSON.stringify(chartTypes['lat/lon/size dot map (continuous color)']));
chartTypes['lat/lon/size dot map (continuous color) (mapbox)'].attr.type = 'scattermapbox';
chartTypes['lat/lon/size dot map (continuous color) (mapbox)'].layout = {
  width: 800,
  height: 400,
  dragmode: 'zoom',
  mapbox: {style: 'carto-positron', center: { lat: 38, lon: -95 }, zoom: 3 },
};

chartTypes['lat/lon/area squares map (mapbox)'] = JSON.parse(JSON.stringify(chartTypes['lat/lon/area squares map']));
chartTypes['lat/lon/area squares map (mapbox)'].attr.type = 'scattermapbox';
chartTypes['lat/lon/area squares map (mapbox)'].layout = {
  width: 800,
  height: 400,
  dragmode: 'zoom',
  mapbox: {style: 'carto-positron', center: { lat: 38, lon: -95 }, zoom: 3 },
  showlegend: true,
};

chartTypes['lat/lon/width line map (mapbox)'] = JSON.parse(JSON.stringify(chartTypes['lat/lon/width line map']));
chartTypes['lat/lon/width line map (mapbox)'].attr.type = 'scattermapbox';
chartTypes['lat/lon/width line map (mapbox)'].layout = {
  width: 800,
  height: 400,
  dragmode: 'zoom',
  mapbox: {style: 'carto-positron', center: { lat: 38, lon: -95 }, zoom: 3 },
};

//Every chart can have explode
for(const k in chartTypes){
  if('wdgTypes' in chartTypes[k]){
    chartTypes[k]['wdgTypes'] = chartTypes[k]['wdgTypes'].concat(['explode']);
  }
}

const sepTraceWdg = ['name','row','col','explode']; //These widgets, if set, will create separate subtraces

const defaultWdgLabels = {
  x: 'X axis',
  y: 'Y axis',
  z: 'Z axis',
  name: 'Color',
  locations: 'Locations',
  text: 'Hover Text',
  radius: 'Radius (m)',
  area: 'Area (sq_km)',
  marker_size: 'Marker Size',
  line_width: 'Line Width',
  marker_color: 'Color',
  lat: 'Latitude',
  lon: 'Longitude',
  lat_start: 'Latitude Start',
  lon_start: 'Longitude Start',
  lat_end: 'Latitude End',
  lon_end: 'Longitude End',
  row: 'Facet Rows',
  col: 'Facet Columns',
  explode: 'Explode',
};

const defaultPlotlyLayout = { //See https://plotly.com/javascript/reference/layout/
  autosize: false,
  width: 400,
  height: 400,
  // font: {
  //   family: 'Courier New, monospace',
  //   size: 14,
  //   color: '#7f7f7f'
  // },
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 40,
  },
  title: {
    text: '',
    yref: "paper",
    y : 1,
    yanchor: "bottom",
    pad: {
      b: 5,
    },
  },
  legend: {
    tracegroupgap: 0,
    itemsizing: 'constant',
  },
  annotations:[],
};

const defaultPlotlyConfig = { //See https://plotly.com/javascript/configuration-options
  editable: false,
  // responsive: true,
  showLink: true,
  plotlyServerURL: "https://chart-studio.plotly.com",
  toImageButtonOptions: { //See https://plotly.com/javascript/configuration-options/#customize-download-plot-options
    format: 'svg', // one of png, svg, jpeg, webp
    scale: 1 // Multiply title/legend/axis/canvas sizes by this factor
  },
};

const rainbow_scl = [[0, 'rgb(150,0,90)'],[0.125, 'rgb(0, 0, 200)'],[0.25,'rgb(0, 25, 255)'],
                     [0.375,'rgb(0, 152, 255)'],[0.5,'rgb(44, 255, 150)'],[0.625,'rgb(151, 255, 0)'],
                     [0.75,'rgb(255, 234, 0)'],[0.875,'rgb(255, 111, 0)'],[1,'rgb(255, 0, 0)']];

const default_colorbar = {
  thickness: 10,
  titleside: 'right',
  outlinecolor: 'rgba(0,0,0,0)',
  ticks: 'outside',
  ticklen: 3,
}

//Maybe note which properties are in layout and which will be in the trace itself. Maybe just use schema?
//But perhaps assume that all trace properties are common across trace types, although some, e.g. 
const customStyle = {
  'Chart Caption': {
    input: 'textarea',
    tooltip: 'Enter figure caption (html allowed)',
  },
  'Plot Width (px)': {
    type: 'layout',
    path: ['width'],
  },
  'Plot Height (px)': {
    type: 'layout',
    path: ['height'],
  },
  'Move Chart Up/Down (px)': {
    tooltip: 'Negative number moves chart up and positive number moves chart down',
  },
  'Move Chart Left/Right (px)': {
    tooltip: 'Negative number moves chart left and positive number moves chart right',
  },
  'Z-index': {
    tooltip: 'Enter a number. Higher z-index will bring to front, lower z-index will move to back.',
  },
  'Plot Title': {
    type: 'layout',
    path: ['title','text'],
    tooltip: 'Manually change the title of the plot.',
  },
  'Plot Title Font Size (pt)': {
    type: 'layout',
    path: ['title','font','size'],
  },
  'X Title': {
    type: 'layout',
    path: ['xaxis','title','text'],
  },
  'X Title Font Size (pt)': {
    type: 'layout',
    path: ['xaxis','title','font','size'],
  },
  'X Tick Font Size (pt)': {
    type: 'layout',
    path: ['xaxis','tickfont','size'],
  },
  'X Label Angle (deg)': {
    type: 'layout',
    path: ['xaxis','tickangle'],
  },
  'X Scale': {
    tooltip: 'Enter a number to scale the x values',
  },
  'X Min': {
    tooltip: 'Right now, "X Min" only works with "X Max" set as well',
  },
  'X Max': {
    tooltip: 'Right now, "X Max" only works with "X Min" set as well',
  },
  'Y Title': {
    type: 'layout',
    path: ['yaxis','title','text'],
  },
  'Y Title Font Size (pt)': {
    type: 'layout',
    path: ['yaxis','title','font','size'],
  },
  'Y Tick Font Size (pt)': {
    type: 'layout',
    path: ['yaxis','tickfont','size'],
  },
  'Y Scale': {
    tooltip: 'Enter a number to scale the y values',
  },
  'Y Min': {
    tooltip: 'Right now, "Y Min" only works with "Y Max" set as well',
  },
  'Y Max': {
    tooltip: 'Right now, "Y Max" only works with "Y Min" set as well',
  },
  'Mapbox Style': {
    type: 'layout',
    path: ['mapbox','style'],
    tooltip: `Free ones are carto-darkmatter, carto-positron, open-street-map,
              stamen-terrain, stamen-toner, stamen-watercolor, white-bg.
              See <a target="_blank" href="https://plotly.com/javascript/reference/layout/mapbox/#layout-mapbox-style">here</a>
              for more information.`,
  },
  'Mapbox Zoom': {
    type: 'layout',
    path: ['mapbox','zoom'],
    tooltip: `Default is 3`,
  },
  'Mapbox Center Latitude': {
    type: 'layout',
    path: ['mapbox','center','lat'],
  },
  'Mapbox Center Longitude': {
    type: 'layout',
    path: ['mapbox','center','lon'],
  },
  'Map Zoom': {
    type: 'layout',
    path: ['geo','projection','scale'],
    tooltip: `Default is 1. More <a target="_blank" href="https://plotly.com/javascript/reference/layout/geo/#layout-geo-projection-scale">here</a>`,
  },
  'Map Center Latitude': {
    type: 'layout',
    path: ['geo','center','lat'],
  },
  'Map Center Longitude': {
    type: 'layout',
    path: ['geo','center','lon'],
  },
  'Bar Width': {
    type: 'data',
    path: ['width'], //this only gets used for bar charts
  },
  'Line Width (px)': {
    type: 'data',
    path: ['line','width'],
  },
  'Dot Size (px)': {
    type: 'data',
    path: ['marker','size'],
    tooltip: 'Default is 6.',
  },
  'Dot Max Value': {
    tooltip: 'Specify the data value to be assigned the "max" marker size.',
  },
  'Opacity (0-1)': {
    type: 'data',
    path: ['opacity'],
  },
  'Histogram size of each bin': {
    type: 'data',
    path: ['xbins','size'],
    tooltip: `Only for histogram plots. Enter number of x-axis bins.
              More <a target="_blank" href="https://plotly.com/javascript/reference/histogram/#histogram-xbins-size">here</a>.`,
  },
  'Boxplot Points': {
    type: 'data',
    path: ['boxpoints'],
    tooltip: `Only for boxplots. Either "all", "outliers", or "suspectedoutliers". Default is false.
              More <a target="_blank" href="https://plotly.com/javascript/reference/box/#box-boxpoints">here</a>.`,
  },
  'Colorscale (marker)': {
    type: 'data',
    path: ['marker','colorscale'],
    tooltip: `For continuous color markers on maps. e.g. Blackbody, Bluered, Blues,
              Cividis, Earth, Electric, Greens, Greys, Hot, Jet, Picnic, Portland, Rainbow,
              RdBu, Reds, Viridis, YlGnBu, YlOrRd.
              More <a target="_blank" href="https://plotly.com/javascript/reference/scattergeo/#scattergeo-marker-colorscale">here</a>`,
  },
  'Reverse Colorscale (marker)': {
    type: 'data',
    path: ['marker','reversescale'],
    tooltip: `Enter 'true' here to reverse the colorscale`,
  },
  'Colorscale Min (marker)': {
    type: 'data',
    path: ['marker','cmin'],
  },
  'Colorscale Max (marker)': {
    type: 'data',
    path: ['marker','cmax'],
  },
  'Colorscale (region)': {
    type: 'data',
    path: ['colorscale'],
    tooltip: `For continuous color region maps. e.g. Blackbody, Bluered, Blues,
              Cividis, Earth, Electric, Greens, Greys, Hot, Jet, Picnic, Portland, Rainbow,
              RdBu, Reds, Viridis, YlGnBu, YlOrRd.
              More <a target="_blank" href="https://plotly.com/javascript/reference/choropleth/#choropleth-colorscale">here</a>`,
  },
  'Reverse Colorscale (region)': {
    type: 'data',
    path: ['reversescale'],
    tooltip: `Enter 'true' here to reverse the colorscale`,
  },
  'Colorscale Min (region)': {
    type: 'data',
    path: ['zmin'],
    tooltip: `This requires Colorscale Max (region)`,
  },
  'Colorscale Max (region)': {
    type: 'data',
    path: ['zmax'],
    tooltip: `This requires Colorscale Min (region)`,
  },
};

$('#file-input').change(function(evt){
  let newFiles = Array.from(evt.target.files);
  //Load all the files asynchronously
  for(let i = 0; i < newFiles.length; i++){
    //If the file already exists, remove the old version
    if(newFiles[i].name in files){
      $(`#file-list li[data-name="${newFiles[i].name}"]`).remove();
      delete files[newFiles[i].name];
    }
    //If this is a config json file, we will save it in config_load and load
    if(newFiles[i].name.startsWith('vizit-config') && newFiles[i].name.endsWith('.json')){
      const reader = new FileReader();
      reader.onload = function(evt) {
        config_load = JSON.parse(evt.target.result);
        $('#file-list').append(
          `<li data-name="${newFiles[i].name}">${newFiles[i].name}
            (requires <b>${config_load.fileNames.join(', ')}</b>)</li>`
        );
        check_and_load_config();
      }
      reader.readAsText(newFiles[i]);
    } else{
    //Else add the new file to the files object and load
      files[newFiles[i].name] = newFiles[i];
      if(!config.fileNames.includes(newFiles[i].name)) config.fileNames.push(newFiles[i].name);
      config.fileNames.sort();
      Papa.parse(newFiles[i], {
        worker: true, //"worker: true" might make things slower, but it prevents the page from hanging...
        header: false,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: function(results, file) {
          rawData[newFiles[i].name] = transpose_to_obj(results.data);
          updateGlobalFilters(newFiles[i].name);
          $('#file-list').append(`<li data-name="${newFiles[i].name}">${newFiles[i].name}</li>`);
          //TODO: When new files are added, update the dynamically added file selects via adding "standard-file-select" class to these widgets
          $('.standard-file-select').append(`<option value="${newFiles[i].name}">${newFiles[i].name}</option>`); //what if we already have this?
          check_and_load_config();
        }
      });
    }
  }
});

$('#global-config-header').click(function(){
  $('#global-config').toggle();
});
$('#data-sources-label').click(function(){
  $('#data-sources').toggle();
});
$('#bottom-controls-label').click(function(){
  $('#bottom-controls').toggle();
});

$('#global-style-file').change(function(){
  if($(this).val() === 'none'){
    delete config.globalStyleFile;
    globalStyles = {};
  } else{
    let selectFile = $(this).val();
    config.globalStyleFile = selectFile;
    updateGlobalStyles(rawData[selectFile]);
  }
  for (const [dash_idx, dash] of traceData.entries()) {
    for (const [chart_idx, chart] of traceData[dash_idx].entries()) {
      updateChart(dash_idx, chart_idx);
    }
  }
});

function updateGlobalStyles(data){
  globalStyles = {};
  for(let i = 0; i < data.column_value.length; i++){
    updateObj(globalStyles, [data.column_name[i], data.column_value[i], 'color'], data.color[i]);
    updateObj(globalStyles, [data.column_name[i], data.column_value[i], 'order'], i);
  }
}

$('#add-url-input').click(function(){
  //TODO: We should share code with file input I think.
  let filePath = $('#url-input').val();
  config.fileNames.push(filePath);
  Papa.parse(filePath, {
    worker: true,
    header: false,
    dynamicTyping: true,
    skipEmptyLines: true,
    download: true,
    complete: function(results) {
      rawData[filePath] = transpose_to_obj(results.data);
      updateGlobalFilters(filePath);
      $('#file-list').append(`<li data-name="${filePath}">${filePath}</li>`);
      $('.standard-file-select').append(`<option value="${filePath}">${filePath}</option>`);
      check_and_load_config();
    }
  });
});

$('#report').on('click','.add-dashboard', function(){
  let dash_idx = config.dashboards.length;
  config.dashboards[dash_idx] = {charts:[]};
  traceData[dash_idx] = [];
  $(this).before(`
    <div id="dash-${dash_idx}" data-dashboardID="${dash_idx}" class="dashboard-outer">
      <div class="dashboard-title-descr-outer">
        <div class="dashboard-title-descr">
          <h2 class="dashboard-title">Dashboard ${dash_idx}</h2>
          <p class="dashboard-descr"></p>
        </div>
        <div class="dashboard-title-descr-edit">
          <input type="text" class="dashboard-title-edit" placeholder="Edit dashboard title"><br>
          <textarea class="dashboard-descr-edit" placeholder="Edit dashboard description"></textarea><br>
          <button class="dashboard-update-title-descr">Update title/description</button>
        </div>
      </div>
      <button class="add-chart">Add Chart</button>
      <button class="remove-dashboard">Remove Dashboard</button>
    </div>
  `);
  //Automatically click to add the first chart
  $(`[data-dashboardID="${dash_idx}"] .add-chart`).click();
});

$('#report').on('click','.remove-dashboard', function(){
  let dash_idx = get_idx(this);
  config.dashboards[dash_idx] = {};
  $(`#dash-${dash_idx}`).remove();
});

$('#report').on('click', '.dashboard-update-title-descr', function(){
  let dash_idx = get_idx(this);
  let title = $(this).siblings('.dashboard-title-edit').val();
  let description = $(this).siblings('.dashboard-descr-edit').val().replace(/(\r\n|\r|\n)/g, '<br>');
  config.dashboards[dash_idx].title = title;
  config.dashboards[dash_idx].description = description;
  $(this).closest('.dashboard-title-descr-outer').find('.dashboard-title').html(title);
  $(this).closest('.dashboard-title-descr-outer').find('.dashboard-descr').html(description);
});

$('#report').on('click','.add-chart', function(){
  let dash_idx = get_idx(this);
  let chart_idx = config.dashboards[dash_idx].charts.length;
  config.dashboards[dash_idx].charts[chart_idx] = {traces:[]};
  traceData[dash_idx][chart_idx] = [];
  //Custom styling
  let styleOptionsHTML = `<option value="none">Add Style</option>`;
  for (const key in customStyle){
    styleOptionsHTML += `<option value="${key}">${key}</option>`;
  }
  //Build html
  let html = `
    <div id="dash-${dash_idx}-chart-${chart_idx}" data-chartID="${chart_idx}" class="chart-outer">
      <div class="chart-controls">
        <div class="chart-title">Chart ${chart_idx}</div>
        <div class="chartstyle-div">
          <label class="styles-label">Change Chart Style</label>
          <select class="add-style">${styleOptionsHTML}</select>
          <button class="update-style">Update Styles</button>
        </div>
        <button class="add-trace">Add Data</button>
        <button class="remove-chart">Remove Chart</button>
      </div>
    </div>
  `;
  $(this).before(html);
  //Automatically click to add the first trace
  $(`#dash-${dash_idx}-chart-${chart_idx} .add-trace`).click();
});

$('#report').on('click','.remove-chart', function(){
  let [dash_idx, chart_idx] = get_idx(this);
  config.dashboards[dash_idx].charts[chart_idx]= {};
  $(`#dash-${dash_idx}-chart-${chart_idx}`).remove();
});

$('#report').on('click','.add-trace', function(){
  let [dash_idx, chart_idx] = get_idx(this);
  let trace_idx = config.dashboards[dash_idx].charts[chart_idx].traces.length;
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx] = {};
  traceData[dash_idx][chart_idx][trace_idx] = {};
  let optionsHtml = `<option value="none">none</option>`;
  for(let fileName of config.fileNames){
    optionsHtml += `<option value="${fileName}">${fileName}</option>`;
  }
  let html = `
    <div id="dash-${dash_idx}-chart-${chart_idx}-trace-${trace_idx}" class="trace-controls" data-traceID="${trace_idx}">
      <div class="trace-title">Data ${trace_idx}</div>
      <label>Data source:</label>
      <select class="data-source">${optionsHtml}</select>
    </div>
  `;
  $(this).before(html);
});

$('#report').on('change','.data-source', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let selectFile = $(this).val();
  let thisDS = $(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].dataSource = selectFile;
  //Do we need the following check? Is it for 'none'?
  if(!config.fileNames.includes(selectFile)){
    return;
  }
  let chartTypeHtml = ``;
  for (const chartType in chartTypes){
    chartTypeHtml+= `<option value="${chartType}">${chartType}</option>`;
  }
  let html = `
  <label>Chart Type:</label>
  <select data-config="type">${chartTypeHtml}</select>
  `;
  //If we have global filters, apply them, else filteredData is rawData
  thisTraceData.filteredData = 'filter' in config ? applyFilters(rawData[selectFile], config.filter) : rawData[selectFile];
  thisTraceData.aggData = thisTraceData.filteredData;
  thisDS.after(html);
});

$('#report').on('change','select[data-config="type"]', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  let chartType = $(this).val();
  let oldChartType = 'type' in trace_config ? trace_config.type : 'none';
  if(chartType == 'none'){
    delete trace_config.type;
  } else{
    trace_config.type = chartType;
    trace_config.agg = chartTypes[chartType].defaultAgg;
  }
  let thisTraceDiv = $(this).parent();
  let selectFile = thisTraceDiv.children('.data-source').val();
  if(selectFile != 'none' && chartType != 'none'){
    if(arraysEqual(chartTypes[chartType].wdgTypes, chartTypes[oldChartType].wdgTypes) &&
      chartTypes[trace_config.type].required.every((val) => val in trace_config)
    ){
      updateChart(dash_idx, chart_idx);
    }
    else{
      buildTraceControls(thisTraceDiv, selectFile, chartType);
    }
  }
});

function buildTraceControls(thisTraceDiv, selectFile, chartType){
  thisTraceDiv.children('.trace-ind-controls').remove();
  let wdgHtml = ``;

  //Add custom widgets
  if ('customIn' in chartTypes[chartType]){
    for(const [key,wdg] of Object.entries(chartTypes[chartType].customIn)){
      wdgHtml += `<label>${wdg.label} `;
      if('tooltip' in wdg){
        wdgHtml += `<span class="tooltip-parent">(?)<span class="tooltip">${wdg.tooltip}</span></span>`
      }
      wdgHtml += `</label>`;
      if(wdg.type == 'text'){
        wdgHtml += `<input class="trace-control" data-config="${key}" type="text">`;
      }
    }
  }
  //Build options for general column-select widgets
  let header = Object.keys(rawData[selectFile]).sort();
  let optionsHtml = '';
  for (const col of header){
    optionsHtml+= `<option value="${col}">${col}</option>`;
  }
  //Add controls for x axis, y axis, color, style, row, column
  const wdgOptionsHtml = `<option value="none">none</option>` + optionsHtml;
  for (const wdgType of chartTypes[chartType].wdgTypes){
    let wdgLabel;
    if('customWdgLabels' in chartTypes[chartType] && wdgType in chartTypes[chartType].customWdgLabels){
      wdgLabel = chartTypes[chartType].customWdgLabels[wdgType];
    } else{
      wdgLabel = defaultWdgLabels[wdgType]
    }
    wdgHtml += `
      <label>${wdgLabel}</label>
      <select class= "trace-control" data-config="${wdgType}">${wdgOptionsHtml}</select>
    `;
  }
  //Add aggregation
  wdgHtml += `
    <label>Aggregation</label>
    <select class="agg trace-control" data-config="agg">
      <option value="none">none</option>
      <option value="sum">Sum</option>
    </select>
  `;
  //Add filters
  const filtOptionsHtml = `<option value="none">Add Filter</option>` + optionsHtml;
  wdgHtml += `
    <div class="filter-div">
      <label class="filters-label">Filters</label>
      <select class="add-filter">${filtOptionsHtml}</select>
      <button class="update-filter update-fil-common">Update Filters</button>
    </div>
  `;

  let html = `<div class="trace-ind-controls">${wdgHtml}</div>`;
  thisTraceDiv.append(html);
  thisTraceDiv.find('.agg').val(chartTypes[chartType].defaultAgg);
}

$('#report').on('change','.trace-control', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  if($(this).val() == 'none' || $(this).val() == ''){
    delete trace_config[$(this).attr('data-config')]
  } else{
    trace_config[$(this).attr('data-config')] = $(this).val();
  }
  if('type' in trace_config &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config)
  ){
    if($(this).attr('data-config') != 'type' || $.isEmptyObject(traceData[dash_idx][chart_idx][trace_idx])){
      if('agg' in trace_config && trace_config.agg != 'none'){
        const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
        const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
          wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
          wdg => trace_config[wdg]);
        thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
      }
      updateTraceData(dash_idx, chart_idx, trace_idx);
    }
    updateChart(dash_idx, chart_idx);
  }
});

function updateGlobalFilters(newFile){
  for (const col in rawData[newFile]){
    if($(`#add-global-filter option[value="${col}"]`).length == 0){
      $(`#add-global-filter`).append(`<option value="${col}">${col}</option>`);
    }
  }
}

function getFilterHTML(column){
  return `
    <div class="filter-outer">
      <label class="filter-name">${column}</label><span class="remove-filter">x</span>
      <select class="filter-type">
        <option value="none">Filter Type</option>
        <option value="select">Select</option>
        <option value="slider">Slider</option>
        <option value="include">Include options</option>
        <option value="exclude">Exclude options</option>
        <option value="equals">Equals</option>
        <option value="greater">Greater than</option>
        <option value="greater-or-equal">Greater than or equal to</option>
        <option value="less">Less than</option>
        <option value="less-or-equal">Less than or equal to</option>
        <option value="between-inclusive">Between (comma-separated)</option>
      </select>
    </div>`;
}

function getFilterSelect(uniques){
  let html = `<select class="filter-val filter-val-select"><option value="0">none</option>`;
  for (let i = 0; i < uniques.length; i++){
    html += `<option value="${i+1}">${uniques[i]}</option>`;
  }
  html += `</select>`;
  return html;
}

function getFilterSlider(uniques){
  let html = `<div class="filter-val">
    <input type="range" min="0" value="0" max="${uniques.length-1}" class="filter-val-slider">`;
  //We store the actual values in a select
  html += `<select class="filter-slider-select">`;
  for (let i = 0; i < uniques.length; i++){
    html += `<option value="${i}">${uniques[i]}</option>`;
  }
  html += `</select></div>`;
  return html;
}

function getFilterCheckBox(uniques){
  let html = `
    <div class="filter-val filter-val-options">
      <div>
        <button class="select-all">All</button>
        <button class="select-none">None</button>
      </div>
      <div>
  `;
  for (let i = 0; i < uniques.length; i++){
    html += `<label><input type="checkbox" name="filter-val" value="${i}">${uniques[i]}</label><br>`;
  }
  html += `</div></div>`;
  return html;
}

$('#add-global-filter').change(function(){
  if($(this).val() == 'none'){
    return;
  }
  let html = getFilterHTML($(this).val());
  $(this).before(html);
  $(this).val('none');
});

$('#report').on('change','.add-filter', function(){
  if($(this).val() == 'none'){
    return;
  }
  let html = getFilterHTML($(this).val());
  $(this).before(html);
  $(this).val('none');
});

$('body').on('click','.remove-filter', function(){
  let filterName = $(this).siblings('.filter-name').text();
  let updateButton;
  if($(this).closest('#global-filter-config').length > 0){
    updateButton = $(this).closest('.filter-div').find('#update-global-filter');
  } else{
    updateButton = $(this).closest('.filter-div').find('.update-filter');
  }
  $(this).parent('.filter-outer').remove();
  updateButton.click();
});

$('body').on('change','.filter-type', function(){
  //If we have filter-val, remove it.
  $(this).next('.filter-val').remove();
  if($(this).val() == 'none'){
    let filterName = $(this).prev('.filter-name').text();
    if(filterName in config.filter){
      delete config.filter[filterName];
    }
    return;
  }
  if(['include','exclude','select','slider'].includes($(this).val())){
    const filterName = $(this).siblings('.filter-name').text();
    let uniques = [];
    if($(this).closest('#global-filter-config').length > 0){
      //First concatenate all values from all rawData with this column,
      //then find uniques
      for (const fileName in rawData){
        if(filterName in rawData[fileName]){
          uniques = uniques.concat(rawData[fileName][filterName])
        }
      }
      uniques = [...new Set(uniques)].sort();
    } else{
      const [dash_idx, chart_idx, trace_idx] = get_idx(this);
      const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
      uniques = [... new Set(rawData[trace_config.dataSource][filterName])].sort(); //maybe uniques should be evaluated and saved earlier...
    }
    let html;
    if(['include','exclude'].includes($(this).val())){
      html = getFilterCheckBox(uniques);
    } else if($(this).val() == 'select'){
      html = getFilterSelect(uniques);
    } else if($(this).val() == 'slider'){
      html = getFilterSlider(uniques);
    }
    $(this).after(html);
  } else{
    $(this).after(`<input class="filter-val filter-val-text" type="text">`);
  }
});

$('body').on('click','.select-all, .select-none', function(){
  const all_bool = $(this).attr('class').includes('select-all');
  $(this).parent().next().find('input').prop('checked',all_bool);
});

function getFilterVal(that){
  let filterVal;
  if($(that).find('.filter-val-options').length > 0){
    filterVal = [];
    $(that).children('.filter-val').find('input:checked').each(function(){
      let changedVal = $(this).parent().text();
      if($.isNumeric(changedVal)){
        changedVal = Number(changedVal);
      }
      filterVal.push(changedVal);
    });
    if (filterVal.length == 0){
      filterVal = undefined;
    }
  } else if($(that).find('.filter-val-text').length > 0){
    let textVal = $(that).find('.filter-val-text').val();
    filterVal = textVal == '' ? undefined : textVal;
  } else if($(that).find('.filter-val-select').length > 0){
    let selectVal = $(that).find('.filter-val-select option:selected').text();
    filterVal = selectVal == 'none' ? undefined : selectVal;
  } else if($(that).find('.filter-val-slider').length > 0){
    let selectVal = $(that).find('.filter-slider-select option:selected').text();
    filterVal = selectVal == 'none' ? undefined : selectVal;
  }
  return filterVal;
}

$('#update-global-filter').click(function(){
  //Build filter config
  config.filter={};
  $(this).siblings('.filter-outer').each(function(){
    let filterVal = getFilterVal(this);
    if (filterVal !== undefined){
      config.filter[$(this).children('.filter-name').text()] = {'filter_type':$(this).children('.filter-type').val(), 'filter_val':filterVal};
    }
  });
  let trace_config, raw_data, thisTraceData, allFilters;
  for (const [dash_idx, dash] of traceData.entries()) {
    for (const [chart_idx, chart] of traceData[dash_idx].entries()) {
      for (const [trace_idx, trace] of traceData[dash_idx][chart_idx].entries()) {
        trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
        raw_data = rawData[trace_config.dataSource];
        thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
        allFilters = {...config.filter, ...trace_config.filter}; //start with global, then overwrite with trace
        thisTraceData.filteredData = applyFilters(raw_data, allFilters);
        thisTraceData.aggData = thisTraceData.filteredData;
        if('type' in trace_config &&
          chartTypes[trace_config.type].required.every((val) => val in trace_config)
        ){
          if('agg' in trace_config && trace_config.agg != 'none'){
            const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
            const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
              wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
              wdg => trace_config[wdg]);
            thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
          }
          updateTraceData(dash_idx, chart_idx, trace_idx);
          updateChart(dash_idx, chart_idx);
        }
      }
    }
  }
});

$('#report').on('click','.update-filter', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  //Build filter config
  trace_config.filter={};
  $(this).siblings('.filter-outer').each(function(){
    let filterVal = getFilterVal(this);
    if (filterVal !== undefined){
      trace_config.filter[$(this).children('.filter-name').text()] = {'filter_type':$(this).children('.filter-type').val(), 'filter_val':filterVal};
    }
  });
  let allFilters = {...config.filter, ...trace_config.filter}; //start with global, then overwrite with trace
  thisTraceData.filteredData = applyFilters(raw_data, allFilters);
  thisTraceData.aggData = thisTraceData.filteredData;
  if('type' in trace_config &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config)
  ){
    if('agg' in trace_config && trace_config.agg != 'none'){
      const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
      const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
        wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
        wdg => trace_config[wdg]);
      thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
    }
    updateTraceData(dash_idx, chart_idx, trace_idx);
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('change','.add-style', function(){
  if($(this).val() == 'none'){
    return;
  }
  let thisStyle = customStyle[$(this).val()];
  let inputHTML;
  if('input' in thisStyle && thisStyle.input == 'textarea'){
    inputHTML = `<textarea class="style-input" rows="1"></textarea>`;
  } else{
    inputHTML = `<input class="style-input" type="text">`;
  }
  let html = `
    <div class="style-outer">
      <label class="style-name">${$(this).val()}</label>
      ${inputHTML}
      <span class="tooltip-parent">(?)<span class="tooltip">${thisStyle.tooltip}</span></span>
      <span class="remove-style">x</span>
    </div>
  `;
  $(this).before(html);
  $(this).val('none');
});

$('#report').on('click','.remove-style', function(){
  let styleName = $(this).siblings('.style-name').text();
  let updateButton = $(this).closest('.chartstyle-div').find('.update-style');
  $(this).parent('.style-outer').remove();
  updateButton.click();
});


$('#report').on('keyup','.style-input', function(){
  if (event.keyCode === 13) {
    $(this).closest('.chartstyle-div').find('.update-style').click();
  }
});

$('body').on('keyup','.filter-val input, input.filter-val', function(){
  if (event.keyCode === 13) {
    $(this).closest('.filter-div').find('.update-fil-common').click();
  }
});

$('body').on('change','.filter-val-text, .filter-val-select', function(){
  $(this).closest('.filter-div').find('.update-fil-common').click();
});

$('body').on('input','.filter-val-slider', function(){
  $(this).next('.filter-slider-select').val($(this).val());
  $(this).closest('.filter-div').find('.update-fil-common').click();
});

$('body').on('change','.filter-slider-select', function(){
  $(this).prev('.filter-val-slider').val($(this).val());
  $(this).closest('.filter-div').find('.update-fil-common').click();
});

$('body').on('load_config_change','.filter-slider-select', function(){
  $(this).prev('.filter-val-slider').val($(this).val());
});

$('#report').on('click','.chartstyle-div .update-style', function(){
  const [dash_idx, chart_idx] = get_idx(this);
  const chart_config = config.dashboards[dash_idx].charts[chart_idx];
  //Build style config
  chart_config.style={};
  $(this).siblings('.style-outer').each(function(){
    chart_config.style[$(this).children('label').text()] = $(this).children('.style-input').val();
  });
  //Make sure we even have a chart to update and, if so, update the chart.
  if(document.getElementById(`chart-container-dash-${dash_idx}-chart-${chart_idx}`)){
    updateChart(dash_idx, chart_idx);
  }
});

$('body').on('click','.filters-label, .styles-label, .filter-name, .trace-title', function(){
  $(this).siblings().toggle();
});

function aggregate(data_in, agg_type, idx_cols, agg_col, help_cols=[]){
  //data_in looks like {col1:[], col2:[],...}
  //agg_type is 'sum',...
  //idx_cols is array of columns to be used as the index
  //agg_col is the column to aggregate
  //help_cols is array of columns needed for some aggregation.

  //Do I split-apply-combine? Right now I'm just applying as i iterate through...
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  let data_in_idx = []; //array of arrays.
  for(const idx_col of idx_cols){
    data_in_idx.push(data_in[idx_col]);
  }
  data_in_idx = transpose(data_in_idx); //now each row is an index value. But does this transpose take too long?
  const idx_out = [];
  const vals = []; //perhaps this should look like {'sum(a)':[]} for agg_type='sum(a)' or {'ave(a)':[],'count':[]} for 'ave(a)' or {'sum(a*b)':[], 'sum(b)':[], 'sum(a*b)/sum(b)':[]} for 'sum(a*b)/sum(b)'? 
  switch(agg_type){
    case 'sum': //TODO: change to 'sum(a)'?
      for(let i = 0; i < data_in_len; i++){
        let idx_out_i = indexOfArr(idx_out, data_in_idx[i]);
        if(idx_out_i == -1){
          idx_out.push(data_in_idx[i]);
          vals.push(data_in[agg_col][i]);
        }else{
          vals[idx_out_i] += data_in[agg_col][i]; //because we're simply summing
        }
      }
      //some operations will require an additional step here to produce vals array...
      break;
  }
  //now we have idx_out and vals arrays to combine into our output object.
  const arr_out = transpose(idx_out); //another transpose, expensive?
  const data_out = {};
  data_out[agg_col] = vals;
  for(let i = 0; i < arr_out.length; i++){
    data_out[idx_cols[i]] = arr_out[i];
  }
  return data_out;
}

function applyFilters(data_in, filters_in = {}){
  //data_in looks like {col1:[], col2:[],...}
  //filters_in looks like {col1: {filter_type: 'include', filter_val:[]},...}
  if($.isEmptyObject(filters_in)){
    return data_in;
  }
  //else (explicit else not needed because of return statement)
  let filters = JSON.parse(JSON.stringify(filters_in)); //Make local copy so i don't change the original
  //Only apply filters that reference columns in data_in
  for(const col in filters_in){
    if(!(col in data_in)) delete filters[col];
  }
  const data_out = {};
  const cols_out = Object.keys(data_in); // before I had a columns=[] argument and const cols_out = (columns.length === 0) ? Object.keys(data_in) : columns;
  for(const col of cols_out){
    data_out[col] = [];
  }
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  const filter_entries = Object.entries(filters);
  loop1:
  for(let i = 0; i < data_in_len; i++){
    //make sure this row passes all filters
    loop2:
    for(const [col_filt, filt] of filter_entries){
      if(['select','slider'].includes(filt.filter_type)){
        if(data_in[col_filt][i] != filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'include'){
        if(!filt.filter_val.includes(data_in[col_filt][i])){
          continue loop1;
        }
      } else if(filt.filter_type == 'exclude'){
        if(filt.filter_val.includes(data_in[col_filt][i])){
          continue loop1;
        }
      } else if(filt.filter_type == 'equals'){
        if(data_in[col_filt][i] != filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'greater'){
        if(data_in[col_filt][i] <= filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'greater-or-equal'){
        if(data_in[col_filt][i] < filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'less'){
        if(data_in[col_filt][i] >= filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'less-or-equal'){
        if(data_in[col_filt][i] > filt.filter_val){
          continue loop1;
        }
      } else if(filt.filter_type == 'between-inclusive'){
        let filt_arr = filt.filter_val.split(',');
        if(data_in[col_filt][i] < filt_arr[0] || data_in[col_filt][i] > filt_arr[1]){
          continue loop1;
        }
      }
    }
    //If we're here, it means this row passed all filters
    for(const col of cols_out){
      data_out[col].push(data_in[col][i]);
    }
  }
  return data_out;
}

function updateTraceData(dash_idx, chart_idx, trace_idx){
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  thisTraceData.subtraces = []; //E.g. a trace could be a series of lines while a subtrace would be each line (plotly disagrees)
  const subtrace_data = thisTraceData.subtraces;
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const agg_data = traceData[dash_idx][chart_idx][trace_idx].aggData;
  const agg_data_len = agg_data[Object.keys(agg_data)[0]].length;
  const sepWdg = []; //Widgets that cause separate subtraces
  const nonsepWdg = []; //Widgets that don't cause separate subtraces
  for(const wdg of chartTypes[trace_config.type].wdgTypes){
    if(wdg in trace_config){
      if(sepTraceWdg.includes(wdg)){
        sepWdg.push(wdg);
      } else {
        nonsepWdg.push(wdg);
      }
    }
  }
  thisTraceData.sepWdg = sepWdg;
  const sepWdgUniques = {};
  thisTraceData.sepWdgUniques = sepWdgUniques;
  for(const wdg of sepWdg){
    sepWdgUniques[wdg] = [];
  }
  //If we don't have sepWdg, it's easy, just pass through the full data as one subtrace
  if(sepWdg.length == 0){
    const newTrace = {};
    for(const wdg of nonsepWdg){
      newTrace[wdg] = agg_data[trace_config[wdg]];
    }
    subtrace_data.push(newTrace); //the array has only one element
  //If we have sepWdg, we need to create a subtrace for each combo of sepWdg values.
  } else{
    for(let i = 0; i < agg_data_len; i++){
      const sepVals = [];
      //find all the values of the sepWdg columns
      for(const wdg of sepWdg){
        sepVals.push(agg_data[trace_config[wdg]][i]);
      }
      //Now loop through the existing subtraces to see if we already have one with the same sepVals.
      //Would probably be smarter to to start with the previous match, rather than from the beginning?
      //Or should I save sepVals as a key, using JSON.stringify? Sounds like JSON.stringify might
      //be slow though itself for small payloads. Might as well not micro-optimize now...
      let sepValsFound = false;
      for(const subtrace of subtrace_data){
        if(arraysEqual(sepVals,subtrace.sepVals)){
          sepValsFound = true;
          for(const wdg of nonsepWdg){
            subtrace[wdg].push(agg_data[trace_config[wdg]][i]);
          }
          break;
        }
      }
      if(!sepValsFound){
        const newSubtrace = {sepVals: sepVals};
        for(const wdg of nonsepWdg){
          newSubtrace[wdg] = [agg_data[trace_config[wdg]][i]];
        }
        subtrace_data.push(newSubtrace);
        //Add to sepWdgUniques if we have any uniques
        for(let j = 0; j < sepWdg.length; j++){
          if(!(sepWdgUniques[sepWdg[j]].includes(sepVals[j]))){
            sepWdgUniques[sepWdg[j]].push(sepVals[j]);
          }
        }
      }
    }
  }
}
function updateChart(dash_idx, chart_idx){
  const chart_config = JSON.parse(JSON.stringify(config.dashboards[dash_idx].charts[chart_idx])); //Maybe structuredClone would be better...
  const chart_data = JSON.parse(JSON.stringify(traceData[dash_idx][chart_idx]));
  if($(`#chart-container-dash-${dash_idx}-chart-${chart_idx}`).length == 0){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).prepend(`<div id="chart-container-dash-${dash_idx}-chart-${chart_idx}" class="chart-container"></div>`);
  }
  //Add styling
  if('style' in chart_config && 'Move Chart Up/Down (px)' in chart_config.style){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).css('top',chart_config.style['Move Chart Up/Down (px)'] + 'px');
  }
  if('style' in chart_config && 'Move Chart Left/Right (px)' in chart_config.style){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).css('left',chart_config.style['Move Chart Left/Right (px)'] + 'px');
  }
  if('style' in chart_config && 'Z-index' in chart_config.style){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).css('z-index',chart_config.style['Z-index']);
  }
  if('style' in chart_config && 'Chart Caption' in chart_config.style){
    if($(`#caption-dash-${dash_idx}-chart-${chart_idx}`).length > 0){
      $(`#caption-dash-${dash_idx}-chart-${chart_idx}`).html(chart_config.style['Chart Caption']);
    }
    else{
      $(`#dash-${dash_idx}-chart-${chart_idx}`).append(`
        <div id="caption-dash-${dash_idx}-chart-${chart_idx}" class="chart-caption">${chart_config.style['Chart Caption']}</div>
      `);
    }
  }
  //Use first trace to figure out if we are exploding.
  let explodes = [null];
  if(chart_data[0].sepWdg.includes('explode')){
    explodes = chart_data[0].sepWdgUniques.explode;
  }
  //If we have exploded charts, remove extras, based on explodes above (from first trace)
  let num_charts = $(`#chart-container-dash-${dash_idx}-chart-${chart_idx} .chart`).length;
  if(num_charts > explodes.length){
    $(`#chart-container-dash-${dash_idx}-chart-${chart_idx} .chart:nth-last-child(-n+${num_charts - explodes.length})`).remove();
  }
  for(let ei = 0; ei < explodes.length; ei++){
    if($(`#chart-dash-${dash_idx}-chart-${chart_idx}-explode-${ei}`).length == 0){
      $(`#chart-container-dash-${dash_idx}-chart-${chart_idx}`).append(`<div id="chart-dash-${dash_idx}-chart-${chart_idx}-explode-${ei}" class="chart"></div>`);
    }
    let explode_val = explodes[ei];
    if(chartTypes[chart_config.traces[0].type].engine == 'plotly'){
      let plotlyData = [];
      let plotlyLayout = JSON.parse(JSON.stringify(defaultPlotlyLayout));
      for(let i = 0; i < chart_data.length; i++){
        if(!('subtraces' in chart_data[i])){
          continue;
        }
        let trace_config = chart_config.traces[i];
        let sepWdg = chart_data[i].sepWdg;
        let sepWdgUniques = chart_data[i].sepWdgUniques;
        let subtrace_data= chart_data[i].subtraces;
        if(chart_data[i].sepWdg.includes('explode')){
          subtrace_data= subtrace_data.filter(st => st.sepVals[chart_data[i].sepWdg.indexOf('explode')] == explode_val);
        }
        let chartType = chartTypes[trace_config.type];
        //Apply default styling for this chart type.
        //Note that multiple chart types in the same chart could conflict here, and if so the last will win.
        if('layout' in chartType){
          for(const prop in chartType['layout']){
            plotlyLayout[prop] = chartType['layout'][prop];
          }
        }
        //Add faceting. If we have multiple traces for a given chart, this will overwrite the layout for each one, so they need to correspond.
        if(sepWdg.includes('row') || sepWdg.includes('col')){
          //TODO: Allow for "independent" pattern, defaulting to ~square rows/columns but allowing user-specified row number or column number.
          //Note that "independent" pattern requires we simply use the subtrace number j to set both xaxis and yaxis.
          plotlyLayout.grid = {pattern:'coupled'};
          plotlyLayout.grid.rows = sepWdg.includes('row') ? sepWdgUniques['row'].length : 1;
          plotlyLayout.grid.columns = sepWdg.includes('col') ? sepWdgUniques['col'].length : 1;
        }
        //The following section is for showing geojson region boundaries
        if('geojsonboundaries' in trace_config){
          let geoFile = trace_config.geojsonboundaries;
          //Instead of using .ajax every time, I should probably store the result in a global variable (.e.g 'globalCache' or something, keyed by the url itself)
          if(!(geoFile in globalCache)){
            $.ajax({
              url: geoFile,
              dataType: 'json',
              async: false,
              success: function(data) {
                globalCache[geoFile] = data;
              }
            });
          }
          let geoData = globalCache[geoFile];
          let location_arr = [];
          let z_arr = [];
          if(geoData.type == 'FeatureCollection'){
            for(let fi = 0; fi < geoData.features.length; fi++) {
              geoData.features[fi].id = fi.toString();
              location_arr.push(fi.toString());
              z_arr.push(0);
            }
          } else if(geoData.type == 'Feature'){
            geoData.id = '0';
            location_arr.push('0');
            z_arr.push(0);
          }
          let boundariesType = chartType.attr.type.includes('mapbox') ? 'choroplethmapbox' : 'choropleth';
          plotlyData.push({
            type: boundariesType,
            locations: location_arr,
            z: z_arr,
            geojson: geoData,
            showscale: false,
            hoverinfo: 'none',
            colorscale: [[0, 'rgba(0,0,0,0)'], [1, 'rgba(0,0,0,0)']],
          });
        }
        //Add the plotly traces (what we call "subtraces")
        let seriesVals = []; //As we go, we'll add unique elements to seriesVals, and if they already exist, showLegend will be false.
        for(const [j, ser] of subtrace_data.entries()){
          if(trace_config.type.startsWith('lat/lon/area squares map')){
            //If this is a lat/lon/area map, we need to find the bounding box and draw it.
            //This expands the lat and lon arrays, and we'll also expand the other arrays to match.
            const new_ser = {};
            const nonLatLons = [];
            for(const prop in ser){
              if(chartType.wdgTypes.includes(prop)){
                new_ser[prop] = [];
                if(prop != 'lat' && prop != 'lon'){
                  nonLatLons.push(prop);
                }
              }
            }
            for(let j = 0; j < ser.lat.length; j++){
              const bb = getBoundingBox(ser.lat[j], ser.lon[j], ser.area[j]**0.5/2);
              new_ser.lat.push(ser.lat[j], null, bb.lat_max, bb.lat_min, bb.lat_min, bb.lat_max, bb.lat_max, null);
              new_ser.lon.push(ser.lon[j], null, bb.lon_min, bb.lon_min, bb.lon_max, bb.lon_max, bb.lon_min, null);
              //for all other properties, simply copy values.
              for(const prop of nonLatLons){
                const serProp = ser[prop][j];
                new_ser[prop].push(serProp, null, serProp, serProp, serProp, serProp, serProp, null);
              }
            }
            for(const prop in new_ser){
              ser[prop] = new_ser[prop];
            }
          }
          let xaxis = 'x'; //These are defaults that can change below if we have rows/columns
          let yaxis = 'y'; //These are defaults that can change below if we have rows/columns
          let layoutXaxis = 'xaxis';
          let layoutYaxis = 'yaxis';
          let rowLabel = '';
          let colLabel = '';
          if(sepWdg.includes('row')){
            var rowVal = ser.sepVals[sepWdg.indexOf('row')];
            let rowNum = sepWdgUniques['row'].indexOf(rowVal) + 1; //axis numbers are one-indexed
            if(rowNum > 1){ //when rowNum = 1, we don't need to specify the yaxis, and it will default to 'y' (which is used instead of 'y1' for some reason).
              yaxis = `y${rowNum}`;
              layoutYaxis = `yaxis${rowNum}`;
            }
            rowLabel = `<b>${rowVal}</b><br><br>`;
          }
          if(sepWdg.includes('col')){
            var colVal = ser.sepVals[sepWdg.indexOf('col')];
            let colNum = sepWdgUniques['col'].indexOf(colVal) + 1; //axis numbers are one-indexed
            if(colNum > 1){ //when colNum = 1, we don't need to specify the yaxis, and it will default to 'x' (which is used instead of 'x1' for some reason).
              xaxis = `x${colNum}`;
              layoutXaxis = `xaxis${colNum}`;
            }
            colLabel = `<br><br><b>${colVal}</b>`;
          }
          ser['xaxis'] = xaxis;
          ser['yaxis'] = yaxis;
          if('x' in trace_config){
            plotlyLayout[layoutXaxis] = {
              automargin: true,
              title: {text: `<br>${trace_config.x}${colLabel}`},
            };
          }
          if('y' in trace_config){
            plotlyLayout[layoutYaxis] = {
              automargin: true,
              title: {text: `${rowLabel}${trace_config.y}<br>`},
            };
          }
          if('marker_size' in trace_config){
            let marker_val_max;
            if('style' in chart_config && 'Dot Max Value' in chart_config['style']){
              marker_val_max = Number(chart_config['style']['Dot Max Value']);
            } else{
              marker_val_max = Math.max(...chart_data[i].aggData[trace_config.marker_size]);
            }
            //using square root of data for marker size because data should be proportional to area (px^2), while marker size is in px
            let marker_size_scaled = ser.marker_size.map(i => Math.sqrt(i) / Math.sqrt(marker_val_max)*10);
            updateObj(ser, ['marker','size'], marker_size_scaled);
          }
          if('marker_color' in trace_config){
            updateObj(ser, ['marker','color'], ser.marker_color);
            ser.marker.colorscale = rainbow_scl;
            ser.marker.colorbar = default_colorbar;
          }
          if('continuousColor' in chartType){
            ser.colorscale = rainbow_scl;
            ser.colorbar = default_colorbar;
          }
          if(sepWdg.includes('name')){
            ser.name = ser.sepVals[sepWdg.indexOf('name')];
            if (!$.isEmptyObject(globalStyles)
            && trace_config.name in globalStyles
            && ser.name in globalStyles[trace_config.name]
            && 'color' in globalStyles[trace_config.name][ser.name]){
              updateObj(ser, ['marker','color'], globalStyles[trace_config.name][ser.name].color);
              updateObj(ser, ['line','color'], globalStyles[trace_config.name][ser.name].color);
            } else{
              updateObj(ser, ['marker','color'], globalColors[sepWdgUniques.name.indexOf(ser.name)]);
              updateObj(ser, ['line','color'], globalColors[sepWdgUniques.name.indexOf(ser.name)]);
            }
          } else{
            ser.name = `Data ${i}`;
            if(!('marker_color' in trace_config)){
              updateObj(ser, ['marker','color'], globalColors[i]);
              updateObj(ser, ['line','color'], globalColors[i]);
            }
          }
          ser.legendgroup = ser.name;
          if(seriesVals.includes(ser.name)){
            ser.showlegend = false;
          } else{
            seriesVals.push(ser.name);
            if(!('marker_color' in trace_config) &&
               !(trace_config.type.startsWith('custom region map'))){
              ser.showlegend = true;
            }
          }
          for(const prop in chartType['attr']){
            ser[prop] = chartType['attr'][prop];
          }
          //Add custom styling that applies to data (must be added to each series, even though this is inefficient...)
          if('style' in chart_config){
            for(const prop in chart_config['style']){
              let propVal = chart_config['style'][prop];
              if(propVal == ''){
                continue;
              }
              if(prop in customStyle && 'type' in customStyle[prop] && customStyle[prop]['type'] == 'data'){
                if(prop == 'Dot Size (px)' && 'marker_size' in trace_config){
                  let marker_size_scaled = ser.marker.size.map(i => i * propVal/6);
                  updateObj(ser, ['marker','size'], marker_size_scaled);
                } else{
                  if(propVal == 'true'){
                    propVal = true;
                  }
                  updateObj(ser, customStyle[prop].path, propVal);
                }
              } else if(prop in customStyle && 'type' in customStyle[prop] && customStyle[prop]['type'] == 'layout'){
                let propPath = [...customStyle[prop].path]; //this uses spread operator to make shallow copy
                if(propPath[0] == 'xaxis'){
                  propPath[0] = layoutXaxis;
                  if(propPath[1] == 'title' && propPath[2] == 'text'){
                    propVal = `<br>${propVal}${colLabel}`;
                  }
                }else if(propPath[0] == 'yaxis'){
                  propPath[0] = layoutYaxis;
                  if(propPath[1] == 'title' && propPath[2] == 'text'){
                    propVal = `${rowLabel}${propVal}<br>`;
                  }
                }
                updateObj(plotlyLayout, propPath, propVal);
              }
              //One-offs
              if(prop == 'X Scale'){
                ser['x'] = ser['x'].map(x => x * propVal);
              } else if(prop == 'Y Scale'){
                ser['y'] = ser['y'].map(y => y * propVal);
              } else if(prop == 'X Min'){
                if(!('range' in plotlyLayout[layoutXaxis])) plotlyLayout[layoutXaxis].range = [null,null];
                plotlyLayout.xaxis.range[0] = Number(propVal);
              } else if(prop == 'X Max'){
                if(!('range' in plotlyLayout[layoutXaxis])) plotlyLayout[layoutXaxis].range = [null,null];
                plotlyLayout.xaxis.range[1] = Number(propVal);
              } else if(prop == 'Y Min'){
                if(!('range' in plotlyLayout[layoutYaxis])) plotlyLayout[layoutYaxis].range = [null,null];
                plotlyLayout.yaxis.range[0] = Number(propVal);
              } else if(prop == 'Y Max'){
                if(!('range' in plotlyLayout[layoutYaxis])) plotlyLayout[layoutYaxis].range = [null,null];
                plotlyLayout.yaxis.range[1] = Number(propVal);
              }
            }
          }
          if(trace_config.type.startsWith('custom region map')){
            ser.geojson = trace_config.geojson;
            if('featureidkey' in trace_config){
              ser.featureidkey = trace_config.featureidkey;
            } else{
              ser.featureidkey = "id";
            }
          }
          if(trace_config.type.startsWith('lat/lon/width line map')){
            const lat_start=ser.lat_start, lat_end=ser.lat_end, lon_start=ser.lon_start, lon_end=ser.lon_end;
            let ser_copy = JSON.parse(JSON.stringify(ser));
            //Remove properties so that it is lighter to copy in for loop below.
            delete ser_copy.lat_start;
            delete ser_copy.lat_end;
            delete ser_copy.lon_start;
            delete ser_copy.lon_end;
            let line_width;
            if('line_width' in trace_config){
              let line_width_max = Math.max(...chart_data[i].aggData[trace_config.line_width]);
              line_width = ser_copy.line_width.map(i => i / line_width_max*10);
              delete ser_copy.line_width;
            }
            let hover_txt;
            if('text' in trace_config){
              hover_txt = ser_copy.text;
              delete ser_copy.text;
            }
            let nsteps = 10;
            for(let j = 0; j<ser.lat_start.length; j++){
              let ser_ln_cp = JSON.parse(JSON.stringify(ser_copy));
              let lat_step = (lat_end[j] - lat_start[j])/nsteps;
              let lon_step = (lon_end[j] - lon_start[j])/nsteps;
              ser_ln_cp.lat = _.range(lat_start[j], lat_end[j] + lat_step, lat_step);
              ser_ln_cp.lon = _.range(lon_start[j], lon_end[j] + lon_step, lon_step);
              if('line_width' in trace_config){
                updateObj(ser_ln_cp, ['line','width'], line_width[j]);
              }
              if('text' in trace_config){
                ser_ln_cp.text = hover_txt[j];
              }
              if(j > 0){
                ser_ln_cp.showlegend = false;
              }
              plotlyData.push(ser_ln_cp);
            }
          }else{
            plotlyData.push(ser);
          }
        }
      }

      //Update html element width and height
      $(`#chart-dash-${dash_idx}-chart-${chart_idx}-explode-${ei}`).width(plotlyLayout.width);
      $(`#chart-dash-${dash_idx}-chart-${chart_idx}-explode-${ei}`).height(plotlyLayout.height);
      $(`#caption-dash-${dash_idx}-chart-${chart_idx}`).width(plotlyLayout.width);
      if(chart_data[0].sepWdg.includes('explode')){
        let plot_title_text = explode_val;
        if('style' in chart_config && 'Plot Title' in chart_config.style){
          plot_title_text = `${chart_config.style['Plot Title']}, ${plot_title_text}`;
        }
        updateObj(plotlyLayout, ['title','text'], plot_title_text);
      }
      Plotly.react(`chart-dash-${dash_idx}-chart-${chart_idx}-explode-${ei}`, plotlyData, plotlyLayout, defaultPlotlyConfig);
      // window.dispatchEvent(new Event('resize')); //This works but maybe we should just be using plotly width and height...
    }
  }
}

function updateObj(obj, keys, value){
  //'obj' is an object, and 'keys' is an array specifying the path of (nested) keys for which we are setting the 'value'.
  keys.forEach(function (item, index) {
    //If this is the final item of path, set it to the value
    if(index == keys.length -1){
      obj[item] = value;
      return;
    }
    //Else add the level if it doesn't exist
    else if(!(item in obj)){
      obj[item] = {};
    }
    //Walk to the next level of the object
    obj = obj[item];
  });
}

function get_idx(that){
  let dash_idx = parseInt($(that).closest('.dashboard-outer').attr('data-dashboardID'));
  if($(that).closest('.chart-outer').length){
    let chart_idx = parseInt($(that).closest('.chart-outer').attr('data-chartID'));
    if($(that).closest('.trace-controls').length){
      let trace_idx = parseInt($(that).closest('.trace-controls').attr('data-traceID'));
      return [dash_idx, chart_idx, trace_idx];
    } else{
      return [dash_idx, chart_idx];
    }
  } else{
    return dash_idx;
  }
}

//TODO: should i really have this? Shouldn't i just use transpose below and then shift()?
//Did i do this because shift needs to re-index and i thought it might be a performance hit?
function transpose_to_obj(matrix_in) {
  //matrix_in is array of arrays
  //obj_out is object with keys as first row of matrix_in and values as transposed matrix_in arrays (minus first row of matrix_in)
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const header = matrix_in[0];
  const obj_out = {};
  for (let j = 0; j < cols; j++) {
    obj_out[header[j]] = Array(rows - 1);
  }
  for (let i = 1; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      obj_out[header[j]][i-1] = matrix_in[i][j];
    }
  }
  return obj_out;
}

//I got the following from https://stackoverflow.com/a/46805290/11048803, "Vanilla Approach"
function transpose(matrix_in) {
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const matrix_out = [];
  for (let j = 0; j < cols; j++) {
    matrix_out[j] = Array(rows);
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      matrix_out[j][i] = matrix_in[i][j];
    }
  }
  return matrix_out;
}

//The following is from https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

//I got the following mostly from https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269
function indexOfArr(arr, subarr){
  for(var i = 0; i<arr.length; i++){
    let checker = false
    for(var j = 0; j<arr[i].length; j++){
      if(arr[i][j] === subarr[j]){
        checker = true
      } else {
        checker = false
        break;
      }
    }
    if (checker){
      return i;
    }
  }
  return -1;
}

//The following is from GeoPoint.prototype.boundingCoordinates of https://github.com/davidwood/node-geopoint/blob/master/geopoint.js,
//which is based on http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates, which i found referenced at:
//https://stackoverflow.com/questions/238260/how-to-calculate-the-bounding-box-for-a-given-lat-lng-location
function getBoundingBox(lat_deg, lon_deg, dist_km){
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 1 / DEG2RAD;
  const EARTH_RADIUS_KM = 6371.01;

  const lat_rad = lat_deg * DEG2RAD;
  const lon_rad = lon_deg * DEG2RAD;
  const radDist = dist_km / EARTH_RADIUS_KM;
  const min_lat_rad = lat_rad - radDist;
  const max_lat_rad = lat_rad + radDist;
  const deltaLon = Math.asin(Math.sin(radDist) / Math.cos(lat_rad));
  const min_lon_rad = lon_rad - deltaLon;
  const max_lon_rad = lon_rad + deltaLon;

  return {
    lat_min: min_lat_rad * RAD2DEG,
    lat_max: max_lat_rad * RAD2DEG,
    lon_min: min_lon_rad * RAD2DEG,
    lon_max: max_lon_rad * RAD2DEG,
  };
}
$('#download-html, #download-html-global-filters, #download-html-no-controls').click(function(){
  var stringifiedConfig = JSON.stringify(config);
  var stringifiedRawData = JSON.stringify(rawData);
  var stringifiedGlobalStyles = JSON.stringify(globalStyles);
  let html_str = orig_html_str.replace(/let config_load = .*;/,`let config_load = ${stringifiedConfig};`)
  html_str = html_str.replace(/let rawData = .*;/,`let rawData = ${stringifiedRawData};`)
  if(this.id == 'download-html-global-filters'){
    let newCSS = `
    #data-sources-label,
    #data-sources,
    #global-config-header,
    #global-style-config,
    #add-global-filter,
    #update-global-filter,
    .filters-label,
    .filter-type,
    #bottom-controls-label,
    .add-dashboard,
    .remove-dashboard,
    .remove-filter,
    .add-chart,
    .add-trace,
    .chart-controls,
    .dashboard-title-descr-edit{
      display: none !important;
    }
    #global-config{
      display: block !important;
    }
    .filter-div,
    #global-config{
      border: none;
    }
    `;
    html_str = html_str.replace('/*no-controls-placeholder*/', newCSS)
  } else if(this.id == 'download-html-no-controls'){
    let newCSS = `
    #top-controls,
    #bottom-controls-label,
    .add-dashboard,
    .remove-dashboard,
    .add-chart,
    .add-trace,
    .chart-controls,
    .dashboard-title-descr-edit{
      display: none !important;
    }
    `;
    html_str = html_str.replace('/*no-controls-placeholder*/', newCSS)
  }
  let content = "data:text/html;charset=utf-8," + encodeURIComponent(html_str);
  const link = document.createElement("a");
  link.setAttribute("href", content);
  link.setAttribute("download", "vizit.html");
  document.body.appendChild(link); // Required for FF
  link.click();
  document.body.removeChild(link);
});
$('#download-json').click(function(){
  let content = "data:text/json;charset=utf-8," + JSON.stringify(config, null, 2);
  const link = document.createElement("a");
  link.setAttribute("href", content);
  link.setAttribute("download", "vizit-config.json");
  document.body.appendChild(link); // Required for FF
  link.click();
  document.body.removeChild(link);
});
$('#download-raw-data').click(function(){
  let rows, rawD, dLen;
  for(const fileName in rawData){
    rawD = rawData[fileName];
    rows = [[]];
    for(const col in rawD){
      rows[0].push(col);
    }
    dLen = rawD[rows[0][0]].length;
    for(let i = 0; i < dLen; i++){
      rows[i+1] = [];
      for(const col in rawD){
        rows[i+1].push(rawD[col][i]);
      }
    }
    let content = "data:text/csv;charset=utf-8," + rows.map(e => e.join(",")).join("\n");
    const link = document.createElement("a");
    link.setAttribute("href", content);
    let fileNameOut = fileName.endsWith('.csv') ? fileName : fileName + '.csv';
    link.setAttribute("download", fileNameOut);
    document.body.appendChild(link); // Required for FF
    link.click();
    document.body.removeChild(link);
  }
});

$('#config-url').click(function(){
  window.open(`https://mmowers.github.io/vizit?config=${encodeURIComponent(JSON.stringify(config))}`, "_blank");
});

function check_and_load_config(){
  if(config_load === null){return;}
  if(config_load.fileNames[0] == '1 file' && !$.isEmptyObject(rawData)){
    //Make first key of rawData equal to '1 file' and remove all others
    let temp = rawData[Object.keys(rawData)[0]];
    rawData = {};
    rawData['1 file'] = temp;
  }
  if(config_load.fileNames[0] == '2 files' && Object.keys(rawData).length == 2){
    //Make '2 files' entry in rawData by concatenating rawData entries together
    //(with added filename column) and remove other entries of rawData.
    let newObj = {};
    for (const [rdkey, rdval] of Object.entries(rawData)) {
      rdval['filename'] = Array(rdval[Object.keys(rdval)[0]].length).fill(rdkey);
      let firstrd = $.isEmptyObject(newObj) ? true : false;
      for (const [colkey, colval] of Object.entries(rdval)) {
        if(firstrd){
          newObj[colkey] = colval;
        } else{
          if(colkey in newObj){
            newObj[colkey] = newObj[colkey].concat(colval);
          } else{
            delete newObj[colkey]; //only keep columns that are in all files
          }
        }
      }
    }
    rawData = {};
    rawData[config_load.fileNames[0]] = newObj;
  }
  if(config_load.fileNames.every(val => val in rawData)){
    $(document).ready(load_config);
  }
}

//Function to import specified configurations.
function load_config(){
  if (config_load === null) {
    return;
  }
  config.fileNames = config_load.fileNames;
  //Configure all the charts like a user would, but do the required widgets last so the charts only get built once.
  //First global styles
  $('#global-config-header').click();
  if('globalStyleFile' in config_load){
    $('#global-style-file').val(config_load.globalStyleFile).change();
  }
  //Now global filters
  if('filter' in config_load){
    for (const key in config_load.filter){
      $(`#add-global-filter`).val(key).change();
      $(`#global-filter-config .filter-type`).last().val(config_load.filter[key]['filter_type']).change();
      if(['include','exclude'].includes(config_load.filter[key].filter_type)){
        $(`#global-filter-config .filter-val`).last().find('label').each(function(){
          if(config_load.filter[key]['filter_val'].map(String).includes($(this).text())){ //perhaps map to string in separate step for speed
            $(this).children('input').prop( "checked", true );
          }
        });
      } else if(config_load.filter[key].filter_type == 'select'){
        $(`#global-filter-config .filter-val`).last().children('option')
        .filter(function(){return $(this).text() === config_load.filter[key].filter_val;})
        .prop("selected", true);
      } else if(config_load.filter[key].filter_type == 'slider'){
        $(`#global-filter-config .filter-slider-select`).last().children('option')
        .filter(function(){return $(this).text() === config_load.filter[key].filter_val;})
        .prop("selected", true).trigger('load_config_change');
      } else {
        $(`#global-filter-config .filter-val`).last().val(config_load.filter[key].filter_val);
      }
    }
    $(`#update-global-filter`).click();
  }
  $('#global-config-header').click();
  //Now all dashboard, chart, and trace config.
  let di = 0;
  for(const db of config_load.dashboards){
    if($.isEmptyObject(db)){
      continue;
    }
    $('.add-dashboard').click();
    //Configure title and description of dashboard
    if('title' in db || 'description' in db){
      if('title' in db){
        $(`[data-dashboardID="${di}"] .dashboard-title-edit`).val(db.title);
      }
      if('description' in db){
        $(`[data-dashboardID="${di}"] .dashboard-descr-edit`).val(db.description);
      }
      $(`[data-dashboardID="${di}"] .dashboard-update-title-descr`).click();
    }
    //Configure charts
    let ci = 0;
    for(const cht of db.charts){
      if($.isEmptyObject(cht)){
        continue;
      }
      if(ci > 0){ //The first one is clicked automatically
        $(`[data-dashboardID="${di}"] .add-chart`).click();
      }
      //Add custom styles for chart
      if('style' in cht){
        $(`#dash-${di}-chart-${ci} .chartstyle-div .styles-label`).click();
        for (const key in cht['style']){
          $(`#dash-${di}-chart-${ci} .chartstyle-div .add-style`).val(key).change();
          $(`#dash-${di}-chart-${ci} .chartstyle-div .style-outer .style-input`).last().val(cht['style'][key]).change();
        }
        $(`#dash-${di}-chart-${ci} .chartstyle-div .update-style`).click();
        $(`#dash-${di}-chart-${ci} .chartstyle-div .styles-label`).click();
      }
      let ti = 0;
      for(const trc of cht.traces){
        if($.isEmptyObject(trc)){
          continue;
        }
        if(ti > 0){ //The first one is clicked automatically
          $(`#dash-${di}-chart-${ci} .add-trace`).click();
        }
        //dataSource first
        if('dataSource' in trc){
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .data-source`).val(trc['dataSource']).change();
        }
        //Now type
        if('type' in trc){
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] [data-config="type"]`).val(trc['type']).change();
        }
        //Now filters
        if('filter' in trc){
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filters-label`).click();
          for (const key in trc['filter']){
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .add-filter`).val(key).change();
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-type`).last().val(trc['filter'][key]['filter_type']).change();
            //If filter type is include or exclude, do the following, else simply fill with value.
            if(['include','exclude'].includes(trc.filter[key].filter_type)){
              $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-val`).last().find('label').each(function(){
                if(trc['filter'][key]['filter_val'].map(String).includes($(this).text())){ //perhaps map to string in separate step for speed
                  $(this).children('input').prop( "checked", true );
                }
              });
            } else if(trc.filter[key].filter_type == 'select'){
              $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-val`).last().children('option')
              .filter(function(){return $(this).text() === trc.filter[key].filter_val;})
              .prop("selected", true);
            } else if(trc.filter[key].filter_type == 'slider'){
              $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-slider-select`).last().children('option')
              .filter(function(){return $(this).text() === trc.filter[key].filter_val;})
              .prop("selected", true).trigger('load_config_change');
            } else{
              $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-val`).last().val(trc.filter[key].filter_val);
            }
          }
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .update-filter`).click();
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filters-label`).click();
        }
        //Add agg and customIn widgets to wdgTypes
        let allWdg = chartTypes[trc.type].wdgTypes.concat(['agg']);
        if('customIn' in chartTypes[trc.type]){
          allWdg = allWdg.concat(Object.keys(chartTypes[trc.type].customIn));
        }
        //Now non-required widgets
        for (const key in trc){
          if(chartTypes[trc.type].required.includes(key)){
            continue;
          }
          if(allWdg.includes(key)){
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] [data-config="${key}"`).val(trc[key]).change();
          }
        }
        //Now required widgets
        for (const key in trc){
          if(chartTypes[trc.type].required.includes(key)){
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] [data-config="${key}"`).val(trc[key]).change();
          }
        }
        ti++;
      }
      ci++;
    }
    di++;
  }
}

//If we have config in the url, retrieve the datasources and set config_load
const urlSearchParams = new URLSearchParams(window.location.search);
const params = Object.fromEntries(urlSearchParams.entries());
if('config' in params){
  config_load = JSON.parse(params.config); //what about decodeURIComponent()? I think it's already decoded.
  //Load all datasources first
  for(let fileName of config_load.fileNames){
    Papa.parse(fileName, {
      worker: true,
      header: false,
      dynamicTyping: true,
      skipEmptyLines: true,
      download: true,
      complete: function(results) {
        rawData[fileName] = transpose_to_obj(results.data);
        //Do we need below inside of the $(document).ready to prevent this html from showing up in orig_html_str?
        updateGlobalFilters(fileName);
        $('#file-list').append(`<li data-name="${fileName}">${fileName}</li>`);
        $('.standard-file-select').append(`<option value="${fileName}">${fileName}</option>`);
        check_and_load_config();
      }
    });
  }
} else{
  //Load config_load if it exists, e.g. if embedded in html via #download-html
  if (config_load !== null) {
    $(document).ready(function(){
      for(let fileName of config_load.fileNames){
        updateGlobalFilters(fileName);
        $('#file-list').append(`<li data-name="${fileName}">${fileName}</li>`);
        $('.standard-file-select').append(`<option value="${fileName}">${fileName}</option>`);
      }
      load_config();
    });
  }
}

</script>
<script>
//The following saves the original html so that we can save into html. It needs to be at the very end so we get everything.
let orig_html_str = $('html').prop('outerHTML');
//we need to remove this one plotly style tag that plotly adds, otherwise it will build up on susequent file download.
let plotly_style = $('html').find('[id="plotly.js-style-global"]').prop('outerHTML');
orig_html_str = orig_html_str.replace(plotly_style, ''); //or see https://stackoverflow.com/questions/1405128/remove-dom-elements-from-jquery-object
orig_html_str = '<!DOCTYPE html>\n' + orig_html_str;
//var orig_html = new XMLSerializer().serializeToString(document); //See https://stackoverflow.com/questions/817218/how-to-get-the-entire-document-html-as-a-string
</script>
</body>
</html>