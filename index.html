<!DOCTYPE html>
<html>
<head>
<title>Vizit</title>
<style>
label {
  font-weight: bold;
}
select{
  display:block;
}
.dashboard-title,
.chart-title,
.trace-title{
  font-weight: bold;
  text-decoration: underline;
}

.dashboard-outer,
.chart-outer,
.trace-controls{
  margin-bottom:20px;
}

.add-dashboard,
.add-chart,
.add-trace{
  display: block;
}

.chart-outer{
  display: inline-block;
}

.chart{
  width: 500px;
  height: 400px;
}

.chart-controls{
  border-style: solid;
  border-width: 1px;
}

.chart + .chart-controls {
  display: none;
}
.chart-outer:hover .chart + .chart-controls{
  display:block;
  position: absolute;
  background-color: white;
  z-index: 10;
}

.filter-div{
  border: 1px solid black;
}

text.js-plot-link-container{
  display:none;
}
.chart-outer:hover text.js-plot-link-container{
  display:block;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.8.0/plotly.min.js'></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
</head>
<body>
<label for="file-input">Data sources:</label><br>
<input type="file" id="file-input" name="files[]" multiple />
<ul id="file-list">(no files selected)</ul>
<div id="report">
  <button class="add-dashboard">Add Dashboard</button>
</div>
<script>
'use strict';
const files = {};
let fileNames = []; //sorted alphabetically
const config = {files:[], dashboards:[]};
const rawData = {}; //mapping of filenames to full raw data (or could this keep too much data in memory?)
const traceData = []; //traceData[dash_idx][chart_idx][trace_idx] = [{x:[...], y:[...], series:'someSeries',...},...]
//Maybe instead keep track of if we've already aggregated data a certain way, defined by filename, an index (sorted array of columns), and value column?
let plotlySchema = {};
// Grab plotly schema synchronously. First set the global configs to synchronous, then json request, then flip back to async.
$.ajaxSetup({async: false});
$.getJSON('https://raw.githubusercontent.com/plotly/plotly.js/master/dist/plot-schema.json', function(data) {
  plotlySchema = data;
});
$.ajaxSetup({async: true});


const chartTypes = {
  'none':{},
  'dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
  },
  'line':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
  },
  'line dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines+markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
  },
  'bar':{
    engine: 'plotly',
    attr: {
      type: 'bar',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    layout:{
      barmode: 'relative',
    },
  },
  '3D dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter3D',
      mode: 'markers',
    },
    wdgTypes: ['x','y','z','series','size'],
    required: ['x','y','z'],
  },
  'lat/lng map':{
    wdgTypes: ['lat','lng','size','series'],
    required:['lat','lng','size'],
    engine:'google',
  }
};

const wdgTypes = {
  x: 'X axis',
  y: 'Y axis',
  z: 'Z axis',
  series: 'Color',
  size: 'Size',
  lat: 'Latitude',
  lng: 'Longitude',
};

const defaultPlotlyLayout = {
  autosize: false,
  width: 500,
  height: 400,
  // font: {
  //   family: 'Courier New, monospace',
  //   size: 14,
  //   color: '#7f7f7f'
  // },
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 40,
  },
  title: {
    text: '',
    yref: "paper",
    y : 1,
    yanchor: "bottom",
    pad: {
      b: 5,
    },
  },
  yaxis: {
    title: {
      text: '',
    },
    automargin: true,
  },
  xaxis: {
    title: {
      text: '',
    },
    automargin: true,
  }
};

const defaultPlotlyConfig = {
  editable: false,
  // responsive: true,
  showLink: true,
  plotlyServerURL: "https://chart-studio.plotly.com"
};

$('#file-input').change(function(evt){
  let newFiles = Array.from(evt.target.files);
  for(let i = 0; i < newFiles.length; i++){
    //If the file already exists, remove the old version
    if(newFiles[i].name in files){
      delete files[newFiles[i].name];
    }
    //Regardless, add the new file to the files object
    files[newFiles[i].name] = newFiles[i];
  }
  //Show files in html, sorted alphabetically
  $('#file-list').empty();
  fileNames = Object.keys(files).sort();
  for(let fileName of fileNames){
    $('#file-list').append(`<li>${fileName}</li>`);
  }
  config.files = fileNames;
});

$('#report').on('click','.add-dashboard', function(){
  let dash_idx = config.dashboards.length;
  config.dashboards[dash_idx] = {charts:[]};
  traceData[dash_idx] = [];
  $(this).before(`
    <div data-dashboardID="${dash_idx}" class="dashboard-outer">
      <div class="dashboard-title">Dashboard ${dash_idx}</div>
      <button class="add-chart">Add Chart</button>
    </div>
  `);
});
$('#report').on('click','.add-chart', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = config.dashboards[dash_idx].charts.length;
  config.dashboards[dash_idx].charts[chart_idx] = {traces:[]};
  traceData[dash_idx][chart_idx] = [];
  $(this).before(`
    <div id="dash-${dash_idx}-chart-${chart_idx}" data-chartID="${chart_idx}" class="chart-outer">
      <div class="chart-controls">
        <div class="chart-title">Chart ${chart_idx}</div>
        <button class="add-trace">Add Data</button>
      </div>
    </div>
  `);
});

$('#report').on('click','.add-trace', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = config.dashboards[dash_idx].charts[chart_idx].traces.length;
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx] = {};
  traceData[dash_idx][chart_idx][trace_idx] = {}; //when adding explode dimensions, this might be an array instead, structured like [[[row1,col1,series1],{}],[[row1,col1,series2],{}]...]
  let optionsHtml = `<option value="none">none</option>`;
  for(let fileName of fileNames){
    optionsHtml += `<option value="${fileName}">${fileName}</option>`;
  }
  let html = `
    <div class="trace-controls" data-traceID="${trace_idx}">
      <div class="trace-title">Data ${trace_idx}</div>
      <label>Data source:</label>
      <select class="data-source">${optionsHtml}</select>
    </div>
  `;
  $(this).before(html);
});
$('#report').on('change','.data-source', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  let selectFile = $(this).val();
  let thisDS = $(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].dataSource = selectFile;
  //Do we need the following check? Is it for 'none'?
  if(!fileNames.includes(selectFile)){
    return;
  }
  let chartTypeHtml = ``;
  for (const chartType in chartTypes){
    chartTypeHtml+= `<option value="${chartType}">${chartType}</option>`;
  }
  let html = `
  <label>Chart Type:</label>
  <select data-config="type">${chartTypeHtml}</select>
  `;
  //If we haven't already gotten the file, grab the data.
  if(!(selectFile in rawData)){
    Papa.parse(files[selectFile], {
      header: false,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: function(results, file) {
        rawData[selectFile] = transpose_to_obj(results.data);
        thisDS.after(html);
      }
    });
  }else{
    thisDS.after(html);
  }
});

$('#report').on('change','select[data-config="type"]', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].type = $(this).val();
  let chartType = $(this).val();
  let thisTraceDiv = $(this).parent();
  let selectFile = thisTraceDiv.children('.data-source').val();
  if(selectFile != 'none' && chartType != 'none'){
    buildTraceControls(thisTraceDiv, selectFile, chartType);
  }
});

function buildTraceControls(thisTraceDiv, selectFile, chartType){
  let header = Object.keys(rawData[selectFile]).sort();
  thisTraceDiv.children('.trace-ind-controls').remove()
  let optionsHtml = `<option value="none">Add Filter</option>`;
  for (const col of header){
    optionsHtml+= `<option value="${col}">${col}</option>`;
  }
  //Add controls for x axis, y axis, color, style, row, column
  let wdgHtml = ``;
  for (const wdgType of chartTypes[chartType].wdgTypes){
    wdgHtml += `
      <label>${wdgTypes[wdgType]}</label>
      <select data-config="${wdgType}">${optionsHtml}</select>
    `;
  }
  wdgHtml += `
    <div class="filter-div">
      <label>Filters</label>
      <select class="add-filter">${optionsHtml}</select>
    </div>
    <button class="update-trace">Update</button>
  `;

  let html = `<div class="trace-ind-controls">${wdgHtml}</div>`;
  thisTraceDiv.append(html);
}

$('#report').on('change','.trace-ind-controls > select', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  let trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config[$(this).attr('data-config')] = $(this).val();
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if($(this).attr('data-config') != 'type' || $.isEmptyObject(traceData[dash_idx][chart_idx][trace_idx])){
      updateTraceData(dash_idx, chart_idx, trace_idx);
    }
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('change','.add-filter', function(){
  if($(this).val() == 'none'){
    return;
  }
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  if(!('filter' in trace_config)){
    trace_config.filter={};
  }
  trace_config.filter[$(this).val()] = {'include_exclude':'include', 'values':[]};
  const uniques = [... new Set(rawData[trace_config.dataSource][$(this).val()])]; //maybe uniques should be evaluated and saved earlier...
  let html = `
    <div class="filter-outer">
      <label class="filter-name">${$(this).val()}</label>
        <select class="include-exclude">
          <option value="include">Include Only</option>
          <option value="exclude">Exclude Only</option>
        </select>
      <div>
        <button class="select-all">All</button>
        <button class="select-none">None</button>
      </div>
      <div class="filter-vals">
  `;
  for (let i = 0; i < uniques.length; i++){
    html += `<label><input type="checkbox" name="filter-val" value="${i}">${uniques[i]}</label><br>`;
  }
  html += `</div></div>`;
  $(this).before(html);
  $(this).val('none');
});

$('#report').on('change','.include-exclude', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config.filter[$(this).prev('.filter-name').text()]['include_exclude'] = $(this).val();
});

$('#report').on('change','.filter-vals input', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const filter_name = $(this).closest('.filter-outer').find('.filter-name').text();
  const vals = trace_config.filter[filter_name]['values'];
  if(this.checked){
    vals.push($(this).parent().text());
  } else {
    vals.splice(vals.indexOf($(this).parent().text()), 1);
  }
});

$('#report').on('click','.select-all, .select-none', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const all_bool = $(this).attr('class').includes('select-all');
  $(this).parent().next().find('input').prop('checked',all_bool).change(); //WARNING: This could be quite time consuming
});

$('#report').on('click','.update-trace', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  // traceData[dash_idx][chart_idx][trace_idx]
  updateTraceData(dash_idx, chart_idx, trace_idx);
  updateChart(dash_idx, chart_idx);
});

function updateTraceData(dash_idx, chart_idx, trace_idx){
  traceData[dash_idx][chart_idx][trace_idx] = {};
  const trace_data = traceData[dash_idx][chart_idx][trace_idx];
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  const raw_data_len = raw_data[Object.keys(raw_data)[0]].length;
  const traceWdg = [];
  for(const wdg of chartTypes[trace_config.type].wdgTypes){
    if(wdg in trace_config && trace_config[wdg] != 'none'){
      traceWdg.push(wdg);
    }
  }
  if (traceWdg.includes('series')){
    for(let i = 0; i < raw_data_len; i++){
      let seriesVal = raw_data[trace_config['series']][i];
      if(!(seriesVal in trace_data)){
        trace_data[seriesVal] = {};
        trace_data[seriesVal].name = seriesVal;
        for(const wdg of traceWdg){
          trace_data[seriesVal][wdg] = [];
        }
      }
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[trace_config[wdg]][i]);
      }
    }
  } else{
    let seriesVal = 'noSeries';
    trace_data[seriesVal] = {};
    for(const wdg of traceWdg){
      trace_data[seriesVal][wdg] = [];
    }
    for(let i = 0; i < raw_data_len; i++){
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[trace_config[wdg]][i]);
      }
    }
  }
}
function updateChart(dash_idx, chart_idx){
  const chart_config = config.dashboards[dash_idx].charts[chart_idx].traces;
  const chart_data = traceData[dash_idx][chart_idx];
  if($(`#chart-dash-${dash_idx}-chart-${chart_idx}`).length == 0){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).prepend(`<div id="chart-dash-${dash_idx}-chart-${chart_idx}" class="chart"></div>`);
  }
  if(chartTypes[chart_config[0].type].engine == 'plotly'){
    let plotlyData = [];
    let plotlyLayout = JSON.parse(JSON.stringify(defaultPlotlyLayout));
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config[i];
      let trace_data= chart_data[i];
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for(const prop in chartType['attr']){
          trace_data[ser][prop] = chartType['attr'][prop];
        }
        //Todo: Size needs to be within marker{}
        plotlyData.push(trace_data[ser]);
        if('layout' in chartType){
          for(const prop in chartType['layout']){
            plotlyLayout[prop] = chartType['layout'][prop];
          }
        }
      }
    }
    Plotly.react(`chart-dash-${dash_idx}-chart-${chart_idx}`, plotlyData, plotlyLayout, defaultPlotlyConfig);
    // window.dispatchEvent(new Event('resize')); //This works but maybe we should just be using plotly width and height...
  } else if(chartTypes[chart_config[0].type].engine == 'google'){
    //I can't figure out how to load google maps script only when needed, something like:
    //$('body').append('<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly"><\/script>');
    //Also note that statement can't have the end script tag exactly because js thinks that thats the end of the script, so we add backslash.
    let gMap = new google.maps.Map(document.getElementById(`chart-dash-${dash_idx}-chart-${chart_idx}`),
    {
      zoom: 3,
      center: { lat: 37.09, lng: -95.712 },
      mapTypeId: "terrain",
    });
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config[i];
      let trace_data= chart_data[i];
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for (let j = 0; j < trace_data[ser]['lat'].length; j++) {
          let mapCircle = new google.maps.Circle({
            strokeWeight: 0,
            fillColor: "#FF0000",
            // fillOpacity: -1/2000*thisMetric + 1, //y=mx + b, where y is opacity, from 0 to 1.
            map:gMap,
            center: {lat: trace_data[ser]['lat'][j], lng: trace_data[ser]['lng'][j]},
            radius: trace_data[ser]['size'][j],
            // customText: 'Reduced Cost: ' + thisMetric + ' $/kW',
          });
          // google.maps.event.addListener(mapCircle, 'click', gmCircleListener);
        }
      }
    }
  }
}

function get_idx(that){
  let dash_idx = parseInt($(that).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(that).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = parseInt($(that).parents('.trace-controls').attr('data-traceID'));
  return [dash_idx, chart_idx, trace_idx];
}

function transpose_to_obj(matrix_in) {
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const header = matrix_in[0];
  const obj_out = [];
  for (let j = 0; j < cols; j++) {
    obj_out[header[j]] = Array(rows - 1);
  }
  for (let i = 1; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      obj_out[header[j]][i-1] = matrix_in[i][j];
    }
  }
  return obj_out;
}

</script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly" async></script>
</body>
</html>