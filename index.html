<!DOCTYPE html>
<html>
<head>
<title>Vizit</title>
<style>
label {
  font-weight: bold;
}
select{
  display:block;
}
.dashboard-title,
.chart-title,
.trace-title{
  font-weight: bold;
  text-decoration: underline;
}
.dashboard-outer,
.chart-outer,
.trace-controls{
  margin-bottom:5px;
}
.add-dashboard,
.add-chart,
.add-trace{
  display: block;
}
.chart-outer{
  display: inline-block;
}
.chart{
  width: 500px;
  height: 400px;
}
.chart-controls{
  border-style: solid;
  border-width: 1px;
}
.chart + .chart-controls {
  display: none;
}
.chart-outer:hover .chart + .chart-controls{
  display:block;
  position: absolute;
  background-color: white;
  z-index: 10;
}
.filter-div, .style-div{
  border: 1px solid black;
}
.filters-label,
.styles-label,
.filter-name,
.trace-title{
  color: #0088cc;
  cursor: pointer;
}
text.js-plot-link-container{
  display:none;
}
.chart-outer:hover text.js-plot-link-container{
  display:block;
}
#download-html,
#download-json{
  color: #0088cc;
  cursor: pointer;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.8.0/plotly.min.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
</head>
<body>
<a style="position: absolute; top: 10px; right: 20px; z-index:100;" href="http://github.com/mmowers/vizit">Vizit GitHub</a>
<label for="file-input">Data sources / config:</label><br>
<input type="file" id="file-input" name="file-input" multiple="multiple">
<ul id="file-list">(no files selected)</ul>
<div id="report">
  <button class="add-dashboard">Add Dashboard</button>
</div>
<div><span id="download-html">Download HTML</span></div>
<div><span id="download-json">Download config JSON</span></div>
<script>
'use strict';
const files = {}; //list of html File objects
let config_load = null; //this gets replaced if we have saved config
let config_load_json_file = null;
const config = {fileNames:[], dashboards:[]}; //fileNames are sorted alphabetically
const rawData = {}; //mapping of filenames to full raw data (or could this keep too much data in memory?)
const traceData = []; //traceData[dash_idx][chart_idx][trace_idx] = {filteredData: {col1:[], col2:[],...}, aggData: {col1:[], col2:[],...}, traces: {'someSeries': {x:[...], y:[...],...},...}}.
//Maybe instead keep track of if we've already aggregated data a certain way, defined by filename, an index (sorted array of columns), and value column?
let plotlySchema = Plotly.PlotSchema.get() //I found this on a forum: https://community.plotly.com/t/plotly-json-schema-reference/21261
// Plotly reference links:
// Single page figure reference: https://plotly.com/javascript/reference/ (this has the schema info as well)
// Function reference: https://plotly.com/javascript/plotlyjs-function-reference (including image download, another resource is: https://plotly.com/javascript/static-image-export/)
// Configuration options: https://plotly.com/javascript/configuration-options/

// This was the old way to get the schema (I found it at https://plotly.com/javascript/reference/index/): Uncomment the following section to grab plotly schema (synchronously). First set the global configs to synchronous, then json request, then flip back to async.
// let plotlySchema = {};
// $.ajaxSetup({async: false});
// $.getJSON('https://raw.githubusercontent.com/plotly/plotly.js/master/dist/plot-schema.json', function(data) {
//   plotlySchema = data;
// });
// $.ajaxSetup({async: true});

const chartTypes = {
  'none':{},
  'dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines+markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'bar':{
    engine: 'plotly',
    attr: {
      type: 'bar',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
    layout:{
      barmode: 'relative',
    },
  },
  '3D dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter3D',
      mode: 'markers',
    },
    wdgTypes: ['x','y','z','series','size'],
    required: ['x','y','z'],
    defaultAgg: 'sum',
    aggCol: 'z',
  },
  'lat/lng map':{
    wdgTypes: ['lat','lng','size','series'],
    required:['lat','lng','size'],
    defaultAgg: 'none',
    aggCol: 'size',
    engine:'google',
  }
};

const wdgTypes = {
  x: 'X axis',
  y: 'Y axis',
  z: 'Z axis',
  series: 'Color',
  size: 'Size',
  lat: 'Latitude',
  lng: 'Longitude',
};

const defaultPlotlyLayout = { //See https://plotly.com/javascript/reference/layout/
  autosize: false,
  width: 500,
  height: 400,
  // font: {
  //   family: 'Courier New, monospace',
  //   size: 14,
  //   color: '#7f7f7f'
  // },
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 40,
  },
  title: {
    text: '',
    yref: "paper",
    y : 1,
    yanchor: "bottom",
    pad: {
      b: 5,
    },
  },
  yaxis: {
    title: {
      text: '',
    },
    automargin: true,
  },
  xaxis: {
    title: {
      text: '',
    },
    automargin: true,
  },
};

const defaultPlotlyConfig = { //See https://plotly.com/javascript/configuration-options
  editable: false,
  // responsive: true,
  showLink: true,
  plotlyServerURL: "https://chart-studio.plotly.com",
  toImageButtonOptions: { //See https://plotly.com/javascript/configuration-options/#customize-download-plot-options
    format: 'svg', // one of png, svg, jpeg, webp
    scale: 1 // Multiply title/legend/axis/canvas sizes by this factor
  },
};

//Maybe note which properties are in layout and which will be in the trace itself. Maybe just use schema?
//But perhaps assume that all trace properties are common across trace types, although some, e.g. 
const customStyle = {
  'layout':{
    'Plot Width (px)': {
      path: ['width'],
    },
    'Plot Height (px)': {
      path: ['height'],
    },
    'Plot Title': {
      path: ['title','text'],
    },
    'Plot Title Font Size': {
      path: ['title','font','size'],
    },
    'X-axis Title': {
      path: ['xaxis','title','text'],
    },
    'X-axis Label Angle (deg)': {
      path: ['xaxis','tickangle'],
    },
    'Y-axis Title': {
      path: ['yaxis','title','text'],
    },
  },
  'data':{
    'Bar Width': {
      path: ['width'], //this only gets used for bar charts
    },
    'Line Width (pt)': {
      path: ['line','width'],
    },
    'Dot Size (pt)': {
      path: ['marker','size'],
    },
    'Opacity (0-1)': {
      path: ['marker','opacity'],
    },
  },
};

/*Bokehpivot default styling
For Plots::
Plot Width (px): 300
Plot Height (px): 300
Plot Title:
Plot Title Font Size: 10
Opacity (0-1): 0.8
Sync Axes: Yes
Flip Axes: No
X Scale: 1
X Min:
X Max:
X Title:
X Title Font Size: 10
X Labels Font Size: 8
X Labels Degrees: 45
Y Scale: 1
Y Min:
Y Max:
Y Title:
Y Title Font Size: 10
Y Labels Font Size: 8
Circle Size (Dot Only): 9
Bar Width (Bar Only): 0.8 (looks like we can set 'width' on the top level of the trace)
Sort Data: Yes
Cumulative Sort: None
Histogram # of bins: 20
Weighted Histogram: Yes
Line Width (Line Only): 2
Show Line/Dot (Range Only): Yes
Add Net Levels to Stacked: Yes
Show Bokeh Tools: Yes
Custom Styles CSV:

For Maps::
Bin Type: Auto Equal Num
# of bins (Auto Only): 9
Ignore Zeros: Yes
Map Palette: Blues
Map Palette 2 (Optional):
Dual Palette Breakpoint (Optional):
Minimum (Equal Width Only):
Maximum (Equal Width Only):
Manual Breakpoints (Manual Only):
Map Width (px): 500
Title Font Size: 10
Boundary Line Width: 0.1
Line Width: 2
Opacity (0-1): 1
Add Arrows: No
Arrow Size (px): 7
Arrow Location (0=start, 1=end): 0.8
*/

$('#file-input').change(function(evt){
  let newFiles = Array.from(evt.target.files);
  for(let i = 0; i < newFiles.length; i++){
    //If the file already exists, remove the old version
    if(newFiles[i].name in files){
      delete files[newFiles[i].name];
    }
    //If this is a json file, we will save it in config_load_json_file.
    if(newFiles[i].name.endsWith('.json')){
      config_load_json_file = newFiles[i];
    } else{
    //Else add the new file to the files object
      files[newFiles[i].name] = newFiles[i];
    }
  }
  //Show files in html, sorted alphabetically
  $('#file-list').empty();
  config.fileNames = Object.keys(files).sort();
  for(let fileName of config.fileNames){
    $('#file-list').append(`<li>${fileName}</li>`);
  }
  //If we have config from a json file, check to make sure all the needed files are in the files object and,
  //if so, call load_config. Otherwise, list the files that are still needed
  if(config_load_json_file != null){
    //maybe a little overkill to read in every time, but the config file can get updated so good for that.
    const reader = new FileReader();
    reader.onload = function(evt) {
      config_load = JSON.parse(evt.target.result);
      const numFiles = config_load.fileNames.length;
      let countFile = 0;
      for(const fileName of config_load.fileNames){
        if(!(fileName in rawData)){
          Papa.parse(files[fileName], {
            worker: true, //"worker: true" might make things slower, but it prevents the page from hanging...
            header: false,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: function(results, file) {
              rawData[fileName] = transpose_to_obj(results.data);
              countFile++;
              if(countFile >= numFiles){
                load_config();
              }
            }
          });
        }
      }
    };
    reader.readAsText(config_load_json_file);
  }
});

$('#report').on('click','.add-dashboard', function(){
  let dash_idx = config.dashboards.length;
  config.dashboards[dash_idx] = {charts:[]};
  traceData[dash_idx] = [];
  $(this).before(`
    <div data-dashboardID="${dash_idx}" class="dashboard-outer">
      <div class="dashboard-title">Dashboard ${dash_idx}</div>
      <button class="add-chart">Add Chart</button>
    </div>
  `);
});
$('#report').on('click','.add-chart', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = config.dashboards[dash_idx].charts.length;
  config.dashboards[dash_idx].charts[chart_idx] = {traces:[]};
  traceData[dash_idx][chart_idx] = [];
  //Custom styling
  let styleOptionsHTML = `<option value="none">Add Style</option>`;
  for (const key in customStyle.layout){
    styleOptionsHTML += `<option value="${key}">${key}</option>`;
  }
  //Build html
  let html = `
    <div id="dash-${dash_idx}-chart-${chart_idx}" data-chartID="${chart_idx}" class="chart-outer">
      <div class="chart-controls">
        <div class="chart-title">Chart ${chart_idx}</div>
        <button class="add-trace">Add Data</button>
        <div class="chartstyle-div">
          <label class="styles-label">Change Chart Style</label>
          <select class="add-style">${styleOptionsHTML}</select>
          <button class="update-style">Update Styles</button>
        </div>
      </div>
    </div>
  `;
  $(this).before(html);
});

$('#report').on('click','.add-trace', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = config.dashboards[dash_idx].charts[chart_idx].traces.length;
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx] = {};
  traceData[dash_idx][chart_idx][trace_idx] = {}; //when adding explode dimensions, this might be an array instead, structured like [[[row1,col1,series1],{}],[[row1,col1,series2],{}]...]
  let optionsHtml = `<option value="none">none</option>`;
  for(let fileName of config.fileNames){
    optionsHtml += `<option value="${fileName}">${fileName}</option>`;
  }
  let html = `
    <div class="trace-controls" data-traceID="${trace_idx}">
      <div class="trace-title">Data ${trace_idx}</div>
      <label>Data source:</label>
      <select class="data-source">${optionsHtml}</select>
    </div>
  `;
  $(this).before(html);
});
$('#report').on('change','.data-source', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let selectFile = $(this).val();
  let thisDS = $(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].dataSource = selectFile;
  //Do we need the following check? Is it for 'none'?
  if(!config.fileNames.includes(selectFile)){
    return;
  }
  let chartTypeHtml = ``;
  for (const chartType in chartTypes){
    chartTypeHtml+= `<option value="${chartType}">${chartType}</option>`;
  }
  let html = `
  <label>Chart Type:</label>
  <select data-config="type">${chartTypeHtml}</select>
  `;
  //If we haven't already gotten the file, grab the data.
  if(!(selectFile in rawData)){
    Papa.parse(files[selectFile], {
      worker: true, //"worker: true" might make things slower, but it prevents the page from hanging...
      header: false,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: function(results, file) {
        rawData[selectFile] = transpose_to_obj(results.data);
        thisTraceData.filteredData = rawData[selectFile];
        thisTraceData.aggData = rawData[selectFile];
        thisDS.after(html);
      }
    });
  }else{
    thisTraceData.filteredData = rawData[selectFile];
    thisTraceData.aggData = rawData[selectFile];
    thisDS.after(html);
  }
});

$('#report').on('change','select[data-config="type"]', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config.type = $(this).val();
  trace_config.agg = chartTypes[$(this).val()].defaultAgg;
  let chartType = $(this).val();
  let thisTraceDiv = $(this).parent();
  let selectFile = thisTraceDiv.children('.data-source').val();
  if(selectFile != 'none' && chartType != 'none'){
    buildTraceControls(thisTraceDiv, selectFile, chartType);
  }
});

function buildTraceControls(thisTraceDiv, selectFile, chartType){
  let header = Object.keys(rawData[selectFile]).sort();
  thisTraceDiv.children('.trace-ind-controls').remove()
  let optionsHtml = '';
  for (const col of header){
    optionsHtml+= `<option value="${col}">${col}</option>`;
  }
  //Add controls for x axis, y axis, color, style, row, column
  const wdgOptionsHtml = `<option value="none">none</option>` + optionsHtml;
  let wdgHtml = ``;
  for (const wdgType of chartTypes[chartType].wdgTypes){
    wdgHtml += `
      <label>${wdgTypes[wdgType]}</label>
      <select data-config="${wdgType}">${wdgOptionsHtml}</select>
    `;
  }
  //Add aggregation
  wdgHtml += `
    <label>Aggregation</label>
    <select class="agg" data-config="agg">
      <option value="none">none</option>
      <option value="sum">Sum</option>
    </select>
  `;
  //Add filters
  const filtOptionsHtml = `<option value="none">Add Filter</option>` + optionsHtml;
  wdgHtml += `
    <div class="filter-div">
      <label class="filters-label">Filters</label>
      <select class="add-filter">${filtOptionsHtml}</select>
      <button class="update-filter">Update Filters</button>
    </div>
  `;
  //Add custom styling
  let styleOptionsHTML = `<option value="none">Add Style</option>`;
  for (const key in customStyle.data){
    styleOptionsHTML += `<option value="${key}">${key}</option>`;
  }
  wdgHtml += `
    <div class="style-div">
      <label class="styles-label">Change Data Style</label>
      <select class="add-style">${styleOptionsHTML}</select>
      <button class="update-style">Update Styles</button>
    </div>
  `;

  let html = `<div class="trace-ind-controls">${wdgHtml}</div>`;
  thisTraceDiv.append(html);
  thisTraceDiv.find('.agg').val(chartTypes[chartType].defaultAgg);
}

$('#report').on('change','.trace-ind-controls > select', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config[$(this).attr('data-config')] = $(this).val();
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if($(this).attr('data-config') != 'type' || $.isEmptyObject(traceData[dash_idx][chart_idx][trace_idx])){
      if('agg' in trace_config && trace_config.agg != 'none'){
        const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
        const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
          wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
          wdg => trace_config[wdg]);
        thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
      }
      updateTraceData(dash_idx, chart_idx, trace_idx);
    }
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('change','.add-filter', function(){
  if($(this).val() == 'none'){
    return;
  }
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const uniques = [... new Set(rawData[trace_config.dataSource][$(this).val()])]; //maybe uniques should be evaluated and saved earlier...
  let html = `
    <div class="filter-outer">
      <label class="filter-name">${$(this).val()}</label>
      <select class="include-exclude">
        <option value="include">Include Only</option>
        <option value="exclude">Exclude Only</option>
      </select>
      <div>
        <button class="select-all">All</button>
        <button class="select-none">None</button>
      </div>
      <div class="filter-vals">
  `;
  for (let i = 0; i < uniques.length; i++){
    html += `<label><input type="checkbox" name="filter-val" value="${i}">${uniques[i]}</label><br>`;
  }
  html += `</div></div>`;
  $(this).before(html);
  $(this).val('none');
});

$('#report').on('click','.select-all, .select-none', function(){
  const all_bool = $(this).attr('class').includes('select-all');
  $(this).parent().next().find('input').prop('checked',all_bool);
});

$('#report').on('click','.update-filter', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  //Build filter config
  trace_config.filter={};
  $(this).siblings('.filter-outer').each(function(){
    const vals = [];
    $(this).children('.filter-vals').find('input:checked').each(function(){
      let changedVal = $(this).parent().text();
      if($.isNumeric(changedVal)){
        changedVal = Number(changedVal);
      }
      vals.push(changedVal);
    });
    if (vals.length > 0){
      trace_config.filter[$(this).children('.filter-name').text()] = {'include_exclude':$(this).children('.include-exclude').val(), 'values':vals};
    }
  });
  thisTraceData.filteredData = applyFilters(raw_data, trace_config.filter);
  thisTraceData.aggData = thisTraceData.filteredData;
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if('agg' in trace_config && trace_config.agg != 'none'){
      const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
      const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
        wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
        wdg => trace_config[wdg]);
      thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
    }
    updateTraceData(dash_idx, chart_idx, trace_idx);
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('change','.add-style', function(){
  if($(this).val() == 'none'){
    return;
  }
  let html = `
    <div class="style-outer">
      <label class="style-name">${$(this).val()}</label>
      <input type="text">
    </div>
  `;
  $(this).before(html);
  $(this).val('none');
});


$('#report').on('click','.style-div .update-style', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  //Build style config
  trace_config.style={};
  $(this).siblings('.style-outer').each(function(){
    trace_config.style[$(this).children('label').text()] = $(this).children('input').val();
  });
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('click','.chartstyle-div .update-style', function(){
  const [dash_idx, chart_idx] = get_chart_idx(this);
  const chart_config = config.dashboards[dash_idx].charts[chart_idx];
  //Build style config
  chart_config.style={};
  $(this).siblings('.style-outer').each(function(){
    chart_config.style[$(this).children('label').text()] = $(this).children('input').val();
  });
  updateChart(dash_idx, chart_idx);
});

$('#report').on('click','.filters-label, .styles-label, .filter-name, .trace-title', function(){
  $(this).siblings().toggle();
});

function aggregate(data_in, agg_type, idx_cols, agg_col, help_cols=[]){
  //data_in looks like {col1:[], col2:[],...}
  //agg_type is 'sum',...
  //idx_cols is array of columns to be used as the index
  //agg_col is the column to aggregate
  //help_cols is array of columns needed for some aggregation.

  //Do I split-apply-combine? Right now I'm just applying as i iterate through...
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  let data_in_idx = []; //array of arrays.
  for(const idx_col of idx_cols){
    data_in_idx.push(data_in[idx_col]);
  }
  data_in_idx = transpose(data_in_idx); //now each row is an index value. But does this transpose take too long?
  const idx_out = [];
  const vals = []; //perhaps this should look like {'sum(a)':[]} for agg_type='sum(a)' or {'ave(a)':[],'count':[]} for 'ave(a)' or {'sum(a*b)':[], 'sum(b)':[], 'sum(a*b)/sum(b)':[]} for 'sum(a*b)/sum(b)'? 
  switch(agg_type){
    case 'sum': //TODO: change to 'sum(a)'?
      for(let i = 0; i < data_in_len; i++){
        let idx_out_i = indexOfArr(idx_out, data_in_idx[i]);
        if(idx_out_i == -1){
          idx_out.push(data_in_idx[i]);
          vals.push(data_in[agg_col][i]);
        }else{
          vals[idx_out_i] += data_in[agg_col][i]; //because we're simply summing
        }
      }
      //some operations will require an additional step here to produce vals array...
      break;
  }
  //now we have idx_out and vals arrays to combine into our output object.
  const arr_out = transpose(idx_out); //another transpose, expensive?
  const data_out = {};
  data_out[agg_col] = vals;
  for(let i = 0; i < arr_out.length; i++){
    data_out[idx_cols[i]] = arr_out[i];
  }
  return data_out;
}

function applyFilters(data_in, filters = {}){
  //data_in looks like {col1:[], col2:[],...}
  //filters looks like {col1: {include_exclude: 'include', values:[]},...}
  if($.isEmptyObject(filters)){
    return data_in;
  }
  //else (actual else not needed because of return statement)
  const data_out = {};
  const cols_out = Object.keys(data_in); // before I had a columns=[] argument and const cols_out = (columns.length === 0) ? Object.keys(data_in) : columns;
  for(const col of cols_out){
    data_out[col] = [];
  }
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  const filter_entries = Object.entries(filters);
  loop1:
  for(let i = 0; i < data_in_len; i++){
    //make sure this row passes all filters
    loop2:
    for(const [col_filt, filt] of filter_entries){
      if(filt.include_exclude == 'include'){
        if(!filt.values.includes(data_in[col_filt][i])){
          continue loop1;
        }
      }else{ //meaning 'exclude'
        if(filt.values.includes(data_in[col_filt][i])){
          continue loop1;
        }
      }
    }
    //If we're here, it means this row passed all filters
    for(const col of cols_out){
      data_out[col].push(data_in[col][i]);
    }
  }
  return data_out;
}

function updateTraceData(dash_idx, chart_idx, trace_idx){
  traceData[dash_idx][chart_idx][trace_idx].traces = {};
  const trace_data = traceData[dash_idx][chart_idx][trace_idx].traces;
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const agg_data = traceData[dash_idx][chart_idx][trace_idx].aggData;
  const agg_data_len = agg_data[Object.keys(agg_data)[0]].length;
  const traceWdg = [];
  for(const wdg of chartTypes[trace_config.type].wdgTypes){
    if(wdg in trace_config && trace_config[wdg] != 'none'){
      traceWdg.push(wdg);
    }
  }
  if (traceWdg.includes('series')){
    for(let i = 0; i < agg_data_len; i++){
      let seriesVal = agg_data[trace_config['series']][i];
      if(!(seriesVal in trace_data)){
        trace_data[seriesVal] = {};
        trace_data[seriesVal].name = seriesVal;
        for(const wdg of traceWdg){
          trace_data[seriesVal][wdg] = [];
        }
      }
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(agg_data[trace_config[wdg]][i]);
      }
    }
  } else{
    let seriesVal = 'noSeries';
    trace_data[seriesVal] = {};
    for(const wdg of traceWdg){
      trace_data[seriesVal][wdg] = [];
    }
    for(let i = 0; i < agg_data_len; i++){
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(agg_data[trace_config[wdg]][i]);
      }
    }
  }
}
function updateChart(dash_idx, chart_idx){
  const chart_config = config.dashboards[dash_idx].charts[chart_idx];
  const chart_data = traceData[dash_idx][chart_idx];
  if($(`#chart-dash-${dash_idx}-chart-${chart_idx}`).length == 0){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).prepend(`<div id="chart-dash-${dash_idx}-chart-${chart_idx}" class="chart"></div>`);
  }
  if(chartTypes[chart_config.traces[0].type].engine == 'plotly'){
    let plotlyData = [];
    let plotlyLayout = JSON.parse(JSON.stringify(defaultPlotlyLayout));
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config.traces[i];
      let trace_data= chart_data[i].traces;
      let chartType = chartTypes[trace_config.type];
      //Apply default styling for this chart type.
      //Note that multiple chart types in the same chart could conflict here, and if so the last will win.
      if('layout' in chartType){
        for(const prop in chartType['layout']){
          plotlyLayout[prop] = chartType['layout'][prop];
        }
      }
      //Add the plotly traces
      for(const ser in trace_data){
        for(const prop in chartType['attr']){
          trace_data[ser][prop] = chartType['attr'][prop];
        }
        //Add custom styling that applies to data (must be added to each series, even though this is inefficient...)
        if('style' in trace_config){
          for(const prop in trace_config['style']){
            updateObj(trace_data[ser], customStyle.data[prop].path, trace_config['style'][prop]);
          }
        }
        //Todo: Size needs to be within marker{}
        plotlyData.push(trace_data[ser]);
      }
    }
    //Add custom styling that applies to layout.
    if('style' in chart_config){
      for(const prop in chart_config['style']){
        updateObj(plotlyLayout, customStyle.layout[prop].path, chart_config['style'][prop]);
      }
    }
    Plotly.react(`chart-dash-${dash_idx}-chart-${chart_idx}`, plotlyData, plotlyLayout, defaultPlotlyConfig);
    // window.dispatchEvent(new Event('resize')); //This works but maybe we should just be using plotly width and height...
  } else if(chartTypes[chart_config.traces[0].type].engine == 'google'){
    //I can't figure out how to load google maps script only when needed, something like:
    //$('body').append('<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly"><\/script>');
    //Also note that statement can't have the end script tag exactly because js thinks that thats the end of the script, so we add backslash.
    let gMap = new google.maps.Map(document.getElementById(`chart-dash-${dash_idx}-chart-${chart_idx}`),
    {
      zoom: 3,
      center: { lat: 37.09, lng: -95.712 },
      mapTypeId: "terrain",
    });
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config.traces[i];
      let trace_data= chart_data[i].traces;
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for (let j = 0; j < trace_data[ser]['lat'].length; j++) {
          let mapCircle = new google.maps.Circle({
            strokeWeight: 0,
            fillColor: "#FF0000",
            // fillOpacity: -1/2000*thisMetric + 1, //y=mx + b, where y is opacity, from 0 to 1.
            map:gMap,
            center: {lat: trace_data[ser]['lat'][j], lng: trace_data[ser]['lng'][j]},
            radius: trace_data[ser]['size'][j],
            // customText: 'Reduced Cost: ' + thisMetric + ' $/kW',
          });
          // google.maps.event.addListener(mapCircle, 'click', gmCircleListener);
        }
      }
    }
  }
  //Common chart styling
  if('style' in chart_config){
    if('Plot Width (px)' in chart_config.style){
      $(`#chart-dash-${dash_idx}-chart-${chart_idx}`).width(chart_config.style['Plot Width (px)']);
    }
    if('Plot Height (px)' in chart_config.style){
      $(`#chart-dash-${dash_idx}-chart-${chart_idx}`).height(chart_config.style['Plot Height (px)']);
    }
  }
}

function updateObj(obj, keys, value){
  //'obj' is an object, and 'keys' is a path of (nested) keys for which we are setting the 'value'.
  keys.forEach(function (item, index) {
    //If this is the final item of path, set it to the value
    if(index == keys.length -1){
      obj[item] = value;
      return;
    }
    //Else add the level if it doesn't exist
    else if(!(item in obj)){
      obj[item] = {};
    }
    //Walk to the next level of the object
    obj = obj[item];
  });
}

function get_idx(that){
  let dash_idx = parseInt($(that).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(that).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = parseInt($(that).parents('.trace-controls').attr('data-traceID'));
  return [dash_idx, chart_idx, trace_idx];
}

function get_chart_idx(that){
  let dash_idx = parseInt($(that).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(that).parents('.chart-outer').attr('data-chartID'));
  return [dash_idx, chart_idx];
}

//TODO: should i really have this? Shouldn't i just use transpose below and then shift()?
//Did i do this because shift needs to re-index and i thought it might be a performance hit?
function transpose_to_obj(matrix_in) {
  //matrix_in is array of arrays
  //obj_out is object with keys as first row of matrix_in and values as transposed matrix_in arrays (minus first row of matrix_in)
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const header = matrix_in[0];
  const obj_out = {};
  for (let j = 0; j < cols; j++) {
    obj_out[header[j]] = Array(rows - 1);
  }
  for (let i = 1; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      obj_out[header[j]][i-1] = matrix_in[i][j];
    }
  }
  return obj_out;
}

//I got the following from https://stackoverflow.com/a/46805290/11048803, "Vanilla Approach"
function transpose(matrix_in) {
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const matrix_out = [];
  for (let j = 0; j < cols; j++) {
    matrix_out[j] = Array(rows);
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      matrix_out[j][i] = matrix_in[i][j];
    }
  }
  return matrix_out;
}

//I got the following mostly from https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269
function indexOfArr(arr, subarr){
  for(var i = 0; i<arr.length; i++){
    let checker = false
    for(var j = 0; j<arr[i].length; j++){
      if(arr[i][j] === subarr[j]){
        checker = true
      } else {
        checker = false
        break;
      }
    }
    if (checker){
      return i;
    }
  }
  return -1;
}
$('#download-html').click(function(){
  var stringifiedConfig = JSON.stringify(config);
  var stringifiedRawData = JSON.stringify(rawData);
  let html_str = orig_html_str.replace(/let config_load = .*;/,`let config_load = ${stringifiedConfig};`)
  html_str = html_str.replace(/const rawData = .*;/,`const rawData = ${stringifiedRawData};`)
  let content = "data:text/html;charset=utf-8," + encodeURIComponent(html_str);
  const link = document.createElement("a");
  link.setAttribute("href", content);
  link.setAttribute("download", "vizit.html");
  document.body.appendChild(link); // Required for FF
  link.click();
  document.body.removeChild(link);
});
$('#download-json').click(function(){
  let content = "data:text/json;charset=utf-8," + JSON.stringify(config, null, 2);
  const link = document.createElement("a");
  link.setAttribute("href", content);
  link.setAttribute("download", "config.json");
  document.body.appendChild(link); // Required for FF
  link.click();
  document.body.removeChild(link);
});

//Function to import specified configurations.
function load_config(){
  if (config_load === null) {
    return;
  }
  config.fileNames = config_load.fileNames;
  //Configure all the charts like a user would.
  config_load.dashboards.forEach((db, di) => {
    $('.add-dashboard').click();
    db.charts.forEach((cht, ci) => {
      $(`[data-dashboardID="${di}"] .add-chart`).click();
      cht.traces.forEach((trc, ti) => {
        $(`#dash-${di}-chart-${ci} .add-trace`).click();
        //dataSource first
        if('dataSource' in trc){
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .data-source`).val(trc['dataSource']).change();
        }
        //Now type
        if('type' in trc){
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] [data-config="type"]`).val(trc['type']).change();
        }
        //Now everything else, except filters
        for (const key in trc){
          if(['filter','dataSource','type'].includes(key)){
            continue;
          }
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] [data-config="${key}"`).val(trc[key]).change();
        }
        //Now filters
        if('filter' in trc){
          for (const key in trc['filter']){
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .add-filter`).val(key).change();
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .include-exclude`).last().val(trc['filter'][key]['include_exclude']).change();
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .filter-vals`).last().children('label').each(function(){
              if(trc['filter'][key]['values'].map(String).includes($(this).text())){ //perhaps map to string in separate step for speed
                $(this).children('input').prop( "checked", true );
              }
            });
          }
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .update-filter`).click();
        }
        //Now custom styles for trace
        if('style' in trc){
          for (const key in trc['style']){
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .add-style`).val(key).change();
            $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .style-outer input`).last().val(trc['style'][key]).change();
          }
          $(`#dash-${di}-chart-${ci} [data-traceID="${ti}"] .update-style`).click();
        }
      });
      //Now custom styles for chart
      if('style' in cht){
        for (const key in cht['style']){
          $(`#dash-${di}-chart-${ci} .chartstyle-div .add-style`).val(key).change();
          $(`#dash-${di}-chart-${ci} .chartstyle-div .style-outer input`).last().val(cht['style'][key]).change();
        }
        $(`#dash-${di}-chart-${ci} .chartstyle-div .update-style`).click();
      }
    });
  });
}
//Load configuration if it exists
$(document).ready(load_config);

</script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly" async></script>
<script>
//The following saves the original html so that we can save into html. It needs to be at the very end so we get everything.
//Maybe we should wait until onload? i think i remember some more google tags ending up in the html on load, though.
//Regardless, those might randomly appear in orig_html via race condition...
let orig_html_str = $('html').prop('outerHTML');
//we need to remove this one plotly style tag that plotly adds, otherwise it will build up on susequent file download.
//After that, the only meaningful difference with the original file is the google key,
//which has &amp; instead of &. See https://stackoverflow.com/questions/5920720/innerhtml-gives-me-as-amp
let plotly_style = $('html').find('[id="plotly.js-style-global"]').prop('outerHTML');
orig_html_str = orig_html_str.replace(plotly_style, ''); //or see https://stackoverflow.com/questions/1405128/remove-dom-elements-from-jquery-object
orig_html_str = '<!DOCTYPE html>\n' + orig_html_str;
//var orig_html = new XMLSerializer().serializeToString(document); //See https://stackoverflow.com/questions/817218/how-to-get-the-entire-document-html-as-a-string
</script>
</body>
</html>