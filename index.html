<!DOCTYPE html>
<html>
<head>
<title>Vizit</title>
<style>
label {
  font-weight: bold;
}
select{
  display:block;
}
.dashboard-title,
.chart-title,
.trace-title{
  font-weight: bold;
  text-decoration: underline;
}

.dashboard-controls,
.chart-controls,
.trace-controls{
  margin-bottom:20px;
}

/* .chart{
  width: 400px;
  height: 400px;
  float: left;
} */
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.8.0/plotly.min.js'></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
</head>
<body>
<div id="controls">
  <label for="file-input">Data sources:</label><br>
  <input type="file" id="file-input" name="files[]" multiple />
  <ul id="file-list">(no files selected)</ul>
  <div id="report-controls">
    <button class="add-dashboard">Add Dashboard</button>
  </div>
</div>
<div id="outputs">
</div>
<script>
'use strict';
const files = {};
let fileNames = []; //sorted alphabetically
const config = {files:[], dashboards:[]};
const rawData = {}; //mapping of filenames to full raw data (or could this keep too much data in memory?)
const traceData = []; //traceData[dash_idx][chart_idx][trace_idx] = [{x:[...], y:[...], series:'someSeries',...},...]
//Maybe instead keep track of if we've already aggregated data a certain way, defined by filename, an index (sorted array of columns), and value column?
let plotlySchema = {};
// Grab plotly schema synchronously. First set the global configs to synchronous, then json request, then flip back to async.
$.ajaxSetup({async: false});
$.getJSON('https://raw.githubusercontent.com/plotly/plotly.js/master/dist/plot-schema.json', function(data) {
  plotlySchema = data;
});
$.ajaxSetup({async: true});


const chartTypes = {
  'none':{},
  'dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
  },
  'line':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
  },
  'line dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines+markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
  },
  'bar':{
    engine: 'plotly',
    attr: {
      type: 'bar',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    layout:{
      barmode: 'relative',
    },
  },
  '3D dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter3D',
      mode: 'markers',
    },
    wdgTypes: ['x','y','z','series','size'],
    required: ['x','y','z'],
  },
  'lat/lng map':{
    wdgTypes: ['lat','lng','size','series'],
    required:['lat','lng'],
    engine:'google',
  }
};

const wdgTypes = {
  x: 'X axis',
  y: 'Y axis',
  z: 'Z axis',
  series: 'Color',
  size: 'Size',
  lat: 'Latitude',
  lng: 'Longitude',
};

const defaultPlotlyLayout = {
  autosize: false,
  width: 500,
  height: 400,
  // font: {
  //   family: 'Courier New, monospace',
  //   size: 14,
  //   color: '#7f7f7f'
  // },
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 40,
  },
  title: {
    text: '',
    yref: "paper",
    y : 1,
    yanchor: "bottom",
    pad: {
      b: 5,
    },
  },
  yaxis: {
    title: {
      text: '',
    },
    automargin: true,
  },
  xaxis: {
    title: {
      text: '',
    },
    automargin: true,
  }
};

const defaultPlotlyConfig = {
  editable: false,
  responsive: false,
  showLink: true,
  plotlyServerURL: "https://chart-studio.plotly.com"
};

$('#file-input').change(function(evt){
  let newFiles = Array.from(evt.target.files);
  for(let i = 0; i < newFiles.length; i++){
    //If the file already exists, remove the old version
    if(newFiles[i].name in files){
      delete files[newFiles[i].name];
    }
    //Regardless, add the new file to the files object
    files[newFiles[i].name] = newFiles[i];
  }
  //Show files in html, sorted alphabetically
  $('#file-list').empty();
  fileNames = Object.keys(files).sort();
  for(let fileName of fileNames){
    $('#file-list').append(`<li>${fileName}</li>`);
  }
  config.files = fileNames;
});

$('#report-controls').on('click','.add-dashboard', function(){
  let dash_idx = config.dashboards.length;
  config.dashboards[dash_idx] = {charts:[]};
  traceData[dash_idx] = [];
  $(this).before(`
    <div data-dashboardID="${dash_idx}" class="dashboard-controls">
      <div class="dashboard-title">Dashboard ${dash_idx}</div>
      <button class="add-chart">Add Chart</button>
    </div>
  `);
});
$('#report-controls').on('click','.add-chart', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-controls').attr('data-dashboardID'));
  let chart_idx = config.dashboards[dash_idx].charts.length;
  config.dashboards[dash_idx].charts[chart_idx] = {traces:[]};
  traceData[dash_idx][chart_idx] = [];
  $(this).before(`
    <div id="dash-${dash_idx}-chart-${chart_idx}" data-chartID="${chart_idx}" class="chart-controls">
      <div class="chart-title">Chart ${chart_idx}</div>
      <button class="add-trace">Add Data</button>
    </div>
  `);
});

$('#report-controls').on('click','.add-trace', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-controls').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-controls').attr('data-chartID'));
  let trace_idx = config.dashboards[dash_idx].charts[chart_idx].traces.length;
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx] = {};
  traceData[dash_idx][chart_idx][trace_idx] = {}; //when adding explode dimensions, this might be an array instead, structured like [[[row1,col1,series1],{}],[[row1,col1,series2],{}]...]
  let optionsHtml = `<option value="none">none</option>`;
  for(let fileName of fileNames){
    optionsHtml += `<option value="${fileName}">${fileName}</option>`;
  }
  let html = `
    <form class="trace-controls" data-traceID="${trace_idx}">
      <div class="trace-title">Data ${trace_idx}</div>
      <label>Data source:</label>
      <select class="data-source">${optionsHtml}</select>
    </form>
  `;
  $(this).before(html);
});
$('#report-controls').on('change','.data-source', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-controls').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-controls').attr('data-chartID'));
  let trace_idx = parseInt($(this).parents('.trace-controls').attr('data-traceID'));
  let selectFile = $(this).val();
  let thisDS = $(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].dataSource = selectFile;
  //Do we need the following check? Is it for 'none'?
  if(!fileNames.includes(selectFile)){
    return;
  }
  let chartTypeHtml = ``;
  for (const chartType in chartTypes){
    chartTypeHtml+= `<option value="${chartType}">${chartType}</option>`;
  }
  let html = `
  <label>Chart Type:</label>
  <select data-config="type">${chartTypeHtml}</select>
  `;
  //If we haven't already gotten the file, grab the data.
  if(!(selectFile in rawData)){
    Papa.parse(files[selectFile], {
      header: false,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: function(results, file) {
        rawData[selectFile] = results.data;
        thisDS.after(html);
      }
    });
  }else{
    thisDS.after(html);
  }
});

$('#report-controls').on('change','select[data-config="type"]', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-controls').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-controls').attr('data-chartID'));
  let trace_idx = parseInt($(this).parents('.trace-controls').attr('data-traceID'));
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].type = $(this).val();
  let chartType = $(this).val();
  let thisTraceDiv = $(this).parent();
  let selectFile = thisTraceDiv.children('.data-source').val();
  if(selectFile != 'none' && chartType != 'none'){
    buildTraceControls(thisTraceDiv, selectFile, chartType);
  }
});

function buildTraceControls(thisTraceDiv, selectFile, chartType){
  let header = rawData[selectFile][0];
  thisTraceDiv.children('.trace-ind-controls').remove()
  let optionsHtml = `<option value="none">none</option>`;
  for (let i = 0; i < header.length; i++){
    optionsHtml+= `<option value="${header[i]}">${header[i]}</option>`;
  }
  //Add controls for x axis, y axis, color, style, row, column
  let wdgHtml = ``;
  for (const wdgType of chartTypes[chartType].wdgTypes){
    wdgHtml += `
      <label>${wdgTypes[wdgType]}</label>
      <select data-config="${wdgType}">${optionsHtml}</select>
    `;
  }

  let html = `<div class="trace-ind-controls">${wdgHtml}</div>`;
  thisTraceDiv.append(html);
}

$('#report-controls').on('change','.trace-ind-controls select', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-controls').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-controls').attr('data-chartID'));
  let trace_idx = parseInt($(this).parents('.trace-controls').attr('data-traceID'));
  let trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config[$(this).attr('data-config')] = $(this).val();
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if($(this).attr('data-config') != 'type' || $.isEmptyObject(traceData[dash_idx][chart_idx][trace_idx])){
      updateTraceData(dash_idx, chart_idx, trace_idx);
    }
    updateChart(dash_idx, chart_idx);
  }
});

function updateTraceData(dash_idx, chart_idx, trace_idx){
  traceData[dash_idx][chart_idx][trace_idx] = {};
  const trace_data = traceData[dash_idx][chart_idx][trace_idx];
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  const header = raw_data[0];
  const ci = {};
  for(let i = 0; i < header.length; i++){
    ci[header[i]] = i;
  }
  const traceWdg = [];
  for(const wdg of chartTypes[trace_config.type].wdgTypes){
    if(wdg in trace_config && trace_config[wdg] != 'none'){
      traceWdg.push(wdg);
    }
  }
  if (traceWdg.includes('series')){
    for(let i = 1; i < raw_data.length; i++){
      let seriesVal = raw_data[i][ci[trace_config['series']]];
      if(!(seriesVal in trace_data)){
        trace_data[seriesVal] = {};
        trace_data[seriesVal].name = seriesVal;
        for(const wdg of traceWdg){
          trace_data[seriesVal][wdg] = [];
        }
      }
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[i][ci[trace_config[wdg]]]);
      }
    }
  } else{
    let seriesVal = 'noSeries';
    trace_data[seriesVal] = {};
    for(const wdg of traceWdg){
      trace_data[seriesVal][wdg] = [];
    }
    for(let i = 1; i < raw_data.length; i++){
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[i][ci[trace_config[wdg]]]);
      }
    }
  }
}
function updateChart(dash_idx, chart_idx){
  const chart_config = config.dashboards[dash_idx].charts[chart_idx].traces;
  const chart_data = traceData[dash_idx][chart_idx];
  if(chartTypes[chart_config[0].type].engine == 'plotly'){
    if($(`#chart-dash-${dash_idx}-chart-${chart_idx}`).length == 0){
      $(`#dash-${dash_idx}-chart-${chart_idx}`).append(`<div id="chart-dash-${dash_idx}-chart-${chart_idx}" class="chart"></div>`);
    }
    let plotlyData = [];
    let plotlyLayout = JSON.parse(JSON.stringify(defaultPlotlyLayout));
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config[i];
      let trace_data= chart_data[i];
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for(const prop in chartType['attr']){
          trace_data[ser][prop] = chartType['attr'][prop];
        }
        plotlyData.push(trace_data[ser])
        if('layout' in chartType){
          for(const prop in chartType['layout']){
            plotlyLayout[prop] = chartType['layout'][prop];
          }
        }
      }
    }
    Plotly.react(`chart-dash-${dash_idx}-chart-${chart_idx}`, plotlyData, plotlyLayout, defaultPlotlyConfig);
  }

}

function transpose(matrix_in) {
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const matrix_out = [];
  for (let i = 0; i < cols; i++) {
    matrix_out[i] = Array(rows);
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      matrix_out[j][i] = matrix_in[i][j];
    }
  }
  return matrix_out;
}

</script>
</body>
</html>