<!DOCTYPE html>
<html>
<head>
<title>Vizit</title>
<style>
label {
  font-weight: bold;
}
select{
  display:block;
}
.dashboard-title,
.chart-title,
.trace-title{
  font-weight: bold;
  text-decoration: underline;
}

.dashboard-outer,
.chart-outer,
.trace-controls{
  margin-bottom:20px;
}

.add-dashboard,
.add-chart,
.add-trace{
  display: block;
}

.chart-outer{
  display: inline-block;
}

.chart{
  width: 500px;
  height: 400px;
}

.chart-controls{
  border-style: solid;
  border-width: 1px;
}

.chart + .chart-controls {
  display: none;
}
.chart-outer:hover .chart + .chart-controls{
  display:block;
  position: absolute;
  background-color: white;
  z-index: 10;
}

.filter-div{
  border: 1px solid black;
}

text.js-plot-link-container{
  display:none;
}
.chart-outer:hover text.js-plot-link-container{
  display:block;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.8.0/plotly.min.js'></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
</head>
<body>
<a style="position: absolute; top: 10px; right: 20px; z-index:100;" href="http://github.com/mmowers/vizit">Vizit GitHub</a>
<label for="file-input">Data sources:</label><br>
<input type="file" id="file-input" name="files[]" multiple />
<ul id="file-list">(no files selected)</ul>
<div id="report">
  <button class="add-dashboard">Add Dashboard</button>
</div>
<script>
'use strict';
const files = {};
let fileNames = []; //sorted alphabetically
const config = {files:[], dashboards:[]};
const rawData = {}; //mapping of filenames to full raw data (or could this keep too much data in memory?)
const traceData = []; //traceData[dash_idx][chart_idx][trace_idx] = {filteredData: {col1:[], col2:[],...}, aggData: {col1:[], col2:[],...}, traces: {'someSeries': {x:[...], y:[...],...},...}}.
//Maybe instead keep track of if we've already aggregated data a certain way, defined by filename, an index (sorted array of columns), and value column?
let plotlySchema = {};
// Grab plotly schema synchronously. First set the global configs to synchronous, then json request, then flip back to async.
$.ajaxSetup({async: false});
$.getJSON('https://raw.githubusercontent.com/plotly/plotly.js/master/dist/plot-schema.json', function(data) {
  plotlySchema = data;
});
$.ajaxSetup({async: true});


const chartTypes = {
  'none':{},
  'dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'line dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter',
      mode: 'lines+markers',
    },
    wdgTypes: ['x','y','series','size'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
  },
  'bar':{
    engine: 'plotly',
    attr: {
      type: 'bar',
    },
    wdgTypes: ['x','y','series'],
    required: ['y'],
    defaultAgg: 'sum',
    aggCol: 'y',
    layout:{
      barmode: 'relative',
    },
  },
  '3D dot':{
    engine: 'plotly',
    attr: {
      type: 'scatter3D',
      mode: 'markers',
    },
    wdgTypes: ['x','y','z','series','size'],
    required: ['x','y','z'],
    defaultAgg: 'sum',
    aggCol: 'z',
  },
  'lat/lng map':{
    wdgTypes: ['lat','lng','size','series'],
    required:['lat','lng','size'],
    defaultAgg: 'none',
    aggCol: 'size',
    engine:'google',
  }
};

const wdgTypes = {
  x: 'X axis',
  y: 'Y axis',
  z: 'Z axis',
  series: 'Color',
  size: 'Size',
  lat: 'Latitude',
  lng: 'Longitude',
};

const defaultPlotlyLayout = {
  autosize: false,
  width: 500,
  height: 400,
  // font: {
  //   family: 'Courier New, monospace',
  //   size: 14,
  //   color: '#7f7f7f'
  // },
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 40,
  },
  title: {
    text: '',
    yref: "paper",
    y : 1,
    yanchor: "bottom",
    pad: {
      b: 5,
    },
  },
  yaxis: {
    title: {
      text: '',
    },
    automargin: true,
  },
  xaxis: {
    title: {
      text: '',
    },
    automargin: true,
  }
};

const defaultPlotlyConfig = {
  editable: false,
  // responsive: true,
  showLink: true,
  plotlyServerURL: "https://chart-studio.plotly.com"
};

$('#file-input').change(function(evt){
  let newFiles = Array.from(evt.target.files);
  for(let i = 0; i < newFiles.length; i++){
    //If the file already exists, remove the old version
    if(newFiles[i].name in files){
      delete files[newFiles[i].name];
    }
    //Regardless, add the new file to the files object
    files[newFiles[i].name] = newFiles[i];
  }
  //Show files in html, sorted alphabetically
  $('#file-list').empty();
  fileNames = Object.keys(files).sort();
  for(let fileName of fileNames){
    $('#file-list').append(`<li>${fileName}</li>`);
  }
  config.files = fileNames;
});

$('#report').on('click','.add-dashboard', function(){
  let dash_idx = config.dashboards.length;
  config.dashboards[dash_idx] = {charts:[]};
  traceData[dash_idx] = [];
  $(this).before(`
    <div data-dashboardID="${dash_idx}" class="dashboard-outer">
      <div class="dashboard-title">Dashboard ${dash_idx}</div>
      <button class="add-chart">Add Chart</button>
    </div>
  `);
});
$('#report').on('click','.add-chart', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = config.dashboards[dash_idx].charts.length;
  config.dashboards[dash_idx].charts[chart_idx] = {traces:[]};
  traceData[dash_idx][chart_idx] = [];
  $(this).before(`
    <div id="dash-${dash_idx}-chart-${chart_idx}" data-chartID="${chart_idx}" class="chart-outer">
      <div class="chart-controls">
        <div class="chart-title">Chart ${chart_idx}</div>
        <button class="add-trace">Add Data</button>
      </div>
    </div>
  `);
});

$('#report').on('click','.add-trace', function(){
  let dash_idx = parseInt($(this).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(this).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = config.dashboards[dash_idx].charts[chart_idx].traces.length;
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx] = {};
  traceData[dash_idx][chart_idx][trace_idx] = {}; //when adding explode dimensions, this might be an array instead, structured like [[[row1,col1,series1],{}],[[row1,col1,series2],{}]...]
  let optionsHtml = `<option value="none">none</option>`;
  for(let fileName of fileNames){
    optionsHtml += `<option value="${fileName}">${fileName}</option>`;
  }
  let html = `
    <div class="trace-controls" data-traceID="${trace_idx}">
      <div class="trace-title">Data ${trace_idx}</div>
      <label>Data source:</label>
      <select class="data-source">${optionsHtml}</select>
    </div>
  `;
  $(this).before(html);
});
$('#report').on('change','.data-source', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let selectFile = $(this).val();
  let thisDS = $(this);
  config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx].dataSource = selectFile;
  //Do we need the following check? Is it for 'none'?
  if(!fileNames.includes(selectFile)){
    return;
  }
  let chartTypeHtml = ``;
  for (const chartType in chartTypes){
    chartTypeHtml+= `<option value="${chartType}">${chartType}</option>`;
  }
  let html = `
  <label>Chart Type:</label>
  <select data-config="type">${chartTypeHtml}</select>
  `;
  //If we haven't already gotten the file, grab the data.
  if(!(selectFile in rawData)){
    Papa.parse(files[selectFile], {
      worker: true, //WARNING: this might make things slower, but it prevents the page from hanging. Might want to turn off tho...
      header: false,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: function(results, file) {
        rawData[selectFile] = transpose_to_obj(results.data);
        thisTraceData.filteredData = rawData[selectFile];
        thisTraceData.aggData = rawData[selectFile];
        thisDS.after(html);
      }
    });
  }else{
    thisTraceData.filteredData = rawData[selectFile];
    thisTraceData.aggData = rawData[selectFile];
    thisDS.after(html);
  }
});

$('#report').on('change','select[data-config="type"]', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config.type = $(this).val();
  trace_config.agg = chartTypes[$(this).val()].defaultAgg;
  let chartType = $(this).val();
  let thisTraceDiv = $(this).parent();
  let selectFile = thisTraceDiv.children('.data-source').val();
  if(selectFile != 'none' && chartType != 'none'){
    buildTraceControls(thisTraceDiv, selectFile, chartType);
  }
});

function buildTraceControls(thisTraceDiv, selectFile, chartType){
  let header = Object.keys(rawData[selectFile]).sort();
  thisTraceDiv.children('.trace-ind-controls').remove()
  let optionsHtml = '';
  for (const col of header){
    optionsHtml+= `<option value="${col}">${col}</option>`;
  }
  //Add controls for x axis, y axis, color, style, row, column
  const wdgOptionsHtml = `<option value="none">none</option>` + optionsHtml;
  let wdgHtml = ``;
  for (const wdgType of chartTypes[chartType].wdgTypes){
    wdgHtml += `
      <label>${wdgTypes[wdgType]}</label>
      <select data-config="${wdgType}">${wdgOptionsHtml}</select>
    `;
  }
  //Add aggregation
  wdgHtml += `
    <label>Aggregation</label>
    <select class="agg" data-config="agg">
      <option value="none">none</option>
      <option value="sum">Sum</option>
    </select>
  `;
  const filtOptionsHtml = `<option value="none">Add Filter</option>` + optionsHtml;
  wdgHtml += `
    <div class="filter-div">
      <label>Filters</label>
      <select class="add-filter">${filtOptionsHtml}</select>
      <button class="update-filter">Update Filters</button>
    </div>
  `;

  let html = `<div class="trace-ind-controls">${wdgHtml}</div>`;
  thisTraceDiv.append(html);
  thisTraceDiv.find('.agg').val(chartTypes[chartType].defaultAgg);
}

$('#report').on('change','.trace-ind-controls > select', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  let trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  trace_config[$(this).attr('data-config')] = $(this).val();
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if($(this).attr('data-config') != 'type' || $.isEmptyObject(traceData[dash_idx][chart_idx][trace_idx])){
      if('agg' in trace_config && trace_config.agg != 'none'){
        const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
        const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
          wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
          wdg => trace_config[wdg]);
        thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
      }
      updateTraceData(dash_idx, chart_idx, trace_idx);
    }
    updateChart(dash_idx, chart_idx);
  }
});

$('#report').on('change','.add-filter', function(){
  if($(this).val() == 'none'){
    return;
  }
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const uniques = [... new Set(rawData[trace_config.dataSource][$(this).val()])]; //maybe uniques should be evaluated and saved earlier...
  let html = `
    <div class="filter-outer">
      <label class="filter-name">${$(this).val()}</label>
      <select class="include-exclude">
        <option value="include">Include Only</option>
        <option value="exclude">Exclude Only</option>
      </select>
      <div>
        <button class="select-all">All</button>
        <button class="select-none">None</button>
      </div>
      <div class="filter-vals">
  `;
  for (let i = 0; i < uniques.length; i++){
    html += `<label><input type="checkbox" name="filter-val" value="${i}">${uniques[i]}</label><br>`;
  }
  html += `</div></div>`;
  $(this).before(html);
  $(this).val('none');
});

$('#report').on('click','.select-all, .select-none', function(){
  const all_bool = $(this).attr('class').includes('select-all');
  $(this).parent().next().find('input').prop('checked',all_bool);
});

$('#report').on('click','.update-filter', function(){
  const [dash_idx, chart_idx, trace_idx] = get_idx(this);
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = rawData[trace_config.dataSource];
  const thisTraceData = traceData[dash_idx][chart_idx][trace_idx];
  //Build filter config
  trace_config.filter={};
  $(this).siblings('.filter-outer').each(function(){
    const vals = [];
    $(this).children('.filter-vals').find('input:checked').each(function(){
      let changedVal = $(this).parent().text();
      if($.isNumeric(changedVal)){
        changedVal = Number(changedVal);
      }
      vals.push(changedVal);
    });
    if (vals.length > 0){
      trace_config.filter[$(this).children('.filter-name').text()] = {'include_exclude':$(this).children('.include-exclude').val(), 'values':vals};
    }
  });
  thisTraceData.filteredData = applyFilters(raw_data, trace_config.filter);
  thisTraceData.aggData = thisTraceData.filteredData;
  if('type' in trace_config && trace_config.type != 'none' &&
    chartTypes[trace_config.type].required.every((val) => val in trace_config) &&
    chartTypes[trace_config.type].required.every((val) => val != 'none')
  ){
    if('agg' in trace_config && trace_config.agg != 'none'){
      const agg_col = trace_config[chartTypes[trace_config.type].aggCol];
      const idx_cols = chartTypes[trace_config.type].wdgTypes.filter(
        wdg => wdg in trace_config && wdg != chartTypes[trace_config.type].aggCol).map(
        wdg => trace_config[wdg]);
      thisTraceData.aggData = aggregate(thisTraceData.filteredData, trace_config.agg, idx_cols, agg_col);
    }
    updateTraceData(dash_idx, chart_idx, trace_idx);
    updateChart(dash_idx, chart_idx);
  }
});
function aggregate(data_in, agg_type, idx_cols, agg_col, help_cols=[]){
  //data_in looks like {col1:[], col2:[],...}
  //agg_type is 'sum',...
  //idx_cols is array of columns to be used as the index
  //agg_col is the column to aggregate
  //help_cols is array of columns needed for some aggregation.

  //Do I split-apply-combine? Right now I'm just applying as i iterate through...
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  let data_in_idx = []; //array of arrays.
  for(const idx_col of idx_cols){
    data_in_idx.push(data_in[idx_col]);
  }
  data_in_idx = transpose(data_in_idx); //now each row is an index value. But does this transpose take too long?
  const idx_out = [];
  const vals = []; //perhaps this should look like {'sum(a)':[]} for agg_type='sum(a)' or {'ave(a)':[],'count':[]} for 'ave(a)' or {'sum(a*b)':[], 'sum(b)':[], 'sum(a*b)/sum(b)':[]} for 'sum(a*b)/sum(b)'? 
  switch(agg_type){
    case 'sum': //TODO: change to 'sum(a)'?
      for(let i = 0; i < data_in_len; i++){
        let idx_out_i = indexOfArr(idx_out, data_in_idx[i]);
        if(idx_out_i == -1){
          idx_out.push(data_in_idx[i]);
          vals.push(data_in[agg_col][i]);
        }else{
          vals[idx_out_i] += data_in[agg_col][i]; //because we're simply summing
        }
      }
      //some operations will require an additional step here to produce vals array...
      break;
  }
  //now we have idx_out and vals arrays to combine into our output object.
  const arr_out = transpose(idx_out); //another transpose, expensive?
  const data_out = {};
  data_out[agg_col] = vals;
  for(let i = 0; i < arr_out.length; i++){
    data_out[idx_cols[i]] = arr_out[i];
  }
  return data_out;
}

function applyFilters(data_in, filters = {}){
  //data_in looks like {col1:[], col2:[],...}
  //filters looks like {col1: {include_exclude: 'include', values:[]},...}
  if($.isEmptyObject(filters)){
    return data_in;
  }
  //else (actual else not needed because of return statement)
  const data_out = {};
  const cols_out = Object.keys(data_in); // before I had a columns=[] argument and const cols_out = (columns.length === 0) ? Object.keys(data_in) : columns;
  for(const col of cols_out){
    data_out[col] = [];
  }
  const data_in_len = data_in[Object.keys(data_in)[0]].length;
  const filter_entries = Object.entries(filters);
  loop1:
  for(let i = 0; i < data_in_len; i++){
    //make sure this row passes all filters
    loop2:
    for(const [col_filt, filt] of filter_entries){
      if(filt.include_exclude == 'include'){
        if(!filt.values.includes(data_in[col_filt][i])){
          continue loop1;
        }
      }else{ //meaning 'exclude'
        if(filt.values.includes(data_in[col_filt][i])){
          continue loop1;
        }
      }
    }
    //If we're here, it means this row passed all filters
    for(const col of cols_out){
      data_out[col].push(data_in[col][i]);
    }
  }
  return data_out;
}

function updateTraceData(dash_idx, chart_idx, trace_idx){
  traceData[dash_idx][chart_idx][trace_idx].traces = {};
  const trace_data = traceData[dash_idx][chart_idx][trace_idx].traces;
  const trace_config = config.dashboards[dash_idx].charts[chart_idx].traces[trace_idx];
  const raw_data = traceData[dash_idx][chart_idx][trace_idx].aggData;
  const raw_data_len = raw_data[Object.keys(raw_data)[0]].length;
  const traceWdg = [];
  for(const wdg of chartTypes[trace_config.type].wdgTypes){
    if(wdg in trace_config && trace_config[wdg] != 'none'){
      traceWdg.push(wdg);
    }
  }
  if (traceWdg.includes('series')){
    for(let i = 0; i < raw_data_len; i++){
      let seriesVal = raw_data[trace_config['series']][i];
      if(!(seriesVal in trace_data)){
        trace_data[seriesVal] = {};
        trace_data[seriesVal].name = seriesVal;
        for(const wdg of traceWdg){
          trace_data[seriesVal][wdg] = [];
        }
      }
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[trace_config[wdg]][i]);
      }
    }
  } else{
    let seriesVal = 'noSeries';
    trace_data[seriesVal] = {};
    for(const wdg of traceWdg){
      trace_data[seriesVal][wdg] = [];
    }
    for(let i = 0; i < raw_data_len; i++){
      for(const wdg of traceWdg){
        trace_data[seriesVal][wdg].push(raw_data[trace_config[wdg]][i]);
      }
    }
  }
}
function updateChart(dash_idx, chart_idx){
  const chart_config = config.dashboards[dash_idx].charts[chart_idx].traces;
  const chart_data = traceData[dash_idx][chart_idx];
  if($(`#chart-dash-${dash_idx}-chart-${chart_idx}`).length == 0){
    $(`#dash-${dash_idx}-chart-${chart_idx}`).prepend(`<div id="chart-dash-${dash_idx}-chart-${chart_idx}" class="chart"></div>`);
  }
  if(chartTypes[chart_config[0].type].engine == 'plotly'){
    let plotlyData = [];
    let plotlyLayout = JSON.parse(JSON.stringify(defaultPlotlyLayout));
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config[i];
      let trace_data= chart_data[i].traces;
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for(const prop in chartType['attr']){
          trace_data[ser][prop] = chartType['attr'][prop];
        }
        //Todo: Size needs to be within marker{}
        plotlyData.push(trace_data[ser]);
        if('layout' in chartType){
          for(const prop in chartType['layout']){
            plotlyLayout[prop] = chartType['layout'][prop];
          }
        }
      }
    }
    Plotly.react(`chart-dash-${dash_idx}-chart-${chart_idx}`, plotlyData, plotlyLayout, defaultPlotlyConfig);
    // window.dispatchEvent(new Event('resize')); //This works but maybe we should just be using plotly width and height...
  } else if(chartTypes[chart_config[0].type].engine == 'google'){
    //I can't figure out how to load google maps script only when needed, something like:
    //$('body').append('<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly"><\/script>');
    //Also note that statement can't have the end script tag exactly because js thinks that thats the end of the script, so we add backslash.
    let gMap = new google.maps.Map(document.getElementById(`chart-dash-${dash_idx}-chart-${chart_idx}`),
    {
      zoom: 3,
      center: { lat: 37.09, lng: -95.712 },
      mapTypeId: "terrain",
    });
    for(let i = 0; i < chart_data.length; i++){
      let trace_config = chart_config[i];
      let trace_data= chart_data[i].traces;
      let chartType = chartTypes[trace_config.type];
      for(const ser in trace_data){
        for (let j = 0; j < trace_data[ser]['lat'].length; j++) {
          let mapCircle = new google.maps.Circle({
            strokeWeight: 0,
            fillColor: "#FF0000",
            // fillOpacity: -1/2000*thisMetric + 1, //y=mx + b, where y is opacity, from 0 to 1.
            map:gMap,
            center: {lat: trace_data[ser]['lat'][j], lng: trace_data[ser]['lng'][j]},
            radius: trace_data[ser]['size'][j],
            // customText: 'Reduced Cost: ' + thisMetric + ' $/kW',
          });
          // google.maps.event.addListener(mapCircle, 'click', gmCircleListener);
        }
      }
    }
  }
}

function get_idx(that){
  let dash_idx = parseInt($(that).parents('.dashboard-outer').attr('data-dashboardID'));
  let chart_idx = parseInt($(that).parents('.chart-outer').attr('data-chartID'));
  let trace_idx = parseInt($(that).parents('.trace-controls').attr('data-traceID'));
  return [dash_idx, chart_idx, trace_idx];
}

//TODO: should i really have this? Shouldn't i just use transpose below and then shift()?
//Did i do this because shift needs to re-index and i thought it might be a performance hit?
function transpose_to_obj(matrix_in) {
  //matrix_in is array of arrays
  //obj_out is object with keys as first row of matrix_in and values as transposed matrix_in arrays (minus first row of matrix_in)
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const header = matrix_in[0];
  const obj_out = [];
  for (let j = 0; j < cols; j++) {
    obj_out[header[j]] = Array(rows - 1);
  }
  for (let i = 1; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      obj_out[header[j]][i-1] = matrix_in[i][j];
    }
  }
  return obj_out;
}

//I got the following from https://stackoverflow.com/a/46805290/11048803, "Vanilla Approach"
function transpose(matrix_in) {
  const rows = matrix_in.length;
  const cols = matrix_in[0].length;
  const matrix_out = [];
  for (let j = 0; j < cols; j++) {
    matrix_out[j] = Array(rows);
  }
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      matrix_out[j][i] = matrix_in[i][j];
    }
  }
  return matrix_out;
}

//I got the following mostly from https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269
function indexOfArr(arr, subarr){
  for(var i = 0; i<arr.length; i++){
    let checker = false
    for(var j = 0; j<arr[i].length; j++){
      if(arr[i][j] === subarr[j]){
        checker = true
      } else {
        checker = false
        break;
      }
    }
    if (checker){
      return i;
    }
  }
  return -1;
}
</script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAIWJ6Gd3cnTqmE3_rYiDZmCwcFVurpjgw&v=weekly" async></script>
</body>
</html>